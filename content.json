[{"title":"Hello World","date":"2017-03-19T12:08:03.635Z","path":"2017/03/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"hexo","date":"2017-03-19T08:55:47.000Z","path":"2017/03/19/hexo/","text":"","tags":[]},{"title":"表单中input框中的一些小技巧","date":"2017-03-12T02:36:31.000Z","path":"2017/03/12/表单中input框中的一些小技巧/","text":"表单中input框中的一些小技巧 时候，我们希望表单中的文本框是只读的，让用户不能修改其中的信息，如使 的内容，”中国”两个字不可以修改。实现的方式归纳一下，有如下几种。 方法1: onfocus=this.blur() 当鼠标放不上就离开焦点 方法2:readonly 方法3: disabled 完整的例子: disabled=”true” 此果文字会变成灰色，不可编辑。readOnly=”true” 文字不会变色，也是不可编辑的 css屏蔽输入： 有两种方法第一：disabled=”disabled”这样定义之后被禁用的 input 元素既不可用，也不可点击。第二：readonly=”readonly” 只读字段是不能修改的。不过，用户仍然可以使用 tab 键切换到该字段，还可以选中或拷贝其文本；","tags":[{"name":"html","slug":"html","permalink":"ZYLZYL.github.io/tags/html/"},{"name":"表单","slug":"表单","permalink":"ZYLZYL.github.io/tags/表单/"}]},{"title":"Websocket","date":"2017-03-06T14:08:05.000Z","path":"2017/03/06/Websocket/","text":"webscket 看完让你彻底搞懂Websocket原理 偶然在知乎上看到一篇回帖，瞬间觉得之前看的那么多资料都不及这一篇回帖让我对 websocket 的认识深刻有木有。所以转到我博客里，分享一下。比较喜欢看这种博客，读起来很轻松，不枯燥，没有布道师的阵仗，纯粹为分享。废话这么多了，最后再赞一个~ 一、websocket与httpWebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）首先HTTP有 1.1 和 1.0 之说，也就是所谓的 keep-alive ，把多个HTTP请求合并为一个，但是 Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已. 有交集，但是并不是全部。另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。通俗来说，你可以用HTTP协议传输非Html数据，就是这样=。=再简单来说，层级不一样。 二、Websocket是什么样的协议，具体有什么优点首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。HTTP的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次HTTP请求就结束了。在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response ，在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。教练，你BB了这么多，跟Websocket有什么关系呢？(:з」∠)好吧，我正准备说Websocket呢。。首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。首先我们来看个典型的 Websocket 握手（借用Wikipedia的。。） 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。我会顺便讲解下作用。 12Upgrade: websocketConnection: Upgrade 这个就是Websocket的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。 123Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。然后， SecWebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~最后， Sec-WebSocket-Version 是告诉服务器所使用的 Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用的一个东西~ 脱水： 服务员，我要的是13岁的噢→→然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！ 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~ 12Upgrade: websocketConnection: Upgrade 依然是固定的，告诉客户端即将升级的是 Websocket 协议，而不是mozillasocket，lurnarsocket或者shitsocket。然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。具体的协议就不在这阐述了。——————技术解析部分完毕—————— 你TMD又BBB了这么久，那到底Websocket有什么鬼用， http long poll ，或者ajax轮询 不都可以实现实时信息传递么。 好好好，年轻人，那我们来讲一讲Websocket有什么用。来给你吃点胡（苏）萝（丹）卜（红） 三、Websocket的作用在讲Websocket之前，我就顺带着讲下 long poll 和 ajax轮询 的原理。ajax轮询ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。场景再现：客户端：啦啦啦，有没有新信息(Request)服务端：没有（Response）客户端：啦啦啦，有没有新信息(Request)服务端：没有。。（Response）客户端：啦啦啦，有没有新信息(Request)服务端：你好烦啊，没有啊。。（Response）客户端：啦啦啦，有没有新消息（Request）服务端：好啦好啦，有啦给你。（Response）客户端：啦啦啦，有没有新消息（Request）服务端：。。。。。没。。。。没。。。没有（Response） —- looplong polllong poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。场景再现：客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）服务端：额。。 等待到有消息的时候。。来 给你（Response）客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。简单地说就是，服务器是一个很懒的冰箱（这是个梗）（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。说完这个，我们再来说一说上面的缺陷（原谅我废话这么多吧OAQ）从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）所以 ajax轮询 和 long poll 都有可能发生这种情况。客户端：啦啦啦啦，有新信息么？服务端：月线正忙，请稍后再试（503 Server Unavailable）客户端：。。。。好吧，啦啦啦，有新信息么？服务端：月线正忙，请稍后再试（503 Server Unavailable）客户端：然后服务端在一旁忙的要死：冰箱，我要更多的冰箱！更多。。更多。。（我错了。。这又是梗。。）言归正传，我们来说Websocket吧通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。哦对了，忘记说了HTTP还是一个状态协议。通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。所以在这种情况下出现了，Websocket出现了。他解决了HTTP的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。所以上面的情景可以做如下修改。客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）客户端：麻烦你有信息的时候推送给我噢。。服务端：ok，有的时候会告诉你的。服务端：balabalabalabala服务端：balabalabalabala服务端：哈哈哈哈哈啊哈哈哈哈服务端：笑死我了哈哈哈哈哈哈哈就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你 ）这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。那么为什么他会解决服务器上消耗资源的问题呢？其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（PHP等）来处理。简单地说，我们有一个非常快速的 接线员（Nginx） ，他负责把问题转交给相应的 客服（Handler） 。本身接线员基本上速度是足够的，但是每次都卡在客服（Handler）了，老有客服处理速度太慢。，导致客服不够。Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。这样就可以解决客服处理速度过慢的问题了。同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的处理时间，而且还会在网路传输中消耗过多的流量/时间。但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了——————–至于怎么在不支持Websocket的客户端上使用Websocket。。答案是： 不能但是可以通过上面说的 long poll 和 ajax 轮询 来 模拟出类似的效果","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"},{"name":"websocket","slug":"websocket","permalink":"ZYLZYL.github.io/tags/websocket/"}]},{"title":"事件委托、函数节流及防抖 ","date":"2017-03-05T14:27:49.000Z","path":"2017/03/05/事件委托、函数节流及防抖/","text":"事件委托、函数节流及防抖 一、事件委托： JS事件处理程序的性能缺陷： 由于事件处理程序可以为现代web应用程序提供交互能力，因此许多开发人员会部分青红皂白的向页面中添加大量的处理程序。在创建GUI的语言（比如C#）中，为GUI中的每一个按钮添加一个onclick事件处理程序是司空见惯的事情，而且这样做也不会导至什么问题。可是在JS中，添加到页面上的事件处理程序都会占用内存，内存占用的越多性能就越差，且必须事先就指定好所有的事件处理程序而导致的DOM访问次数的增加会延迟整个页面的交互就绪时间。 ————《JavaScript高级程序设计（三版）》 我想JS高程中对于事件处理程序中的问题说的很清楚了，基本上就是说事件处理程序绑定的越多越影响性能，但是又不能说不绑定事件，所以我们需要一种方法来减少绑定的事件。 事件对象： 在触发DOM上的某个事件的时候，就会产生一个事件对象event，这个对象中包含着所有与事件有关的信息，其中包括导至事件的元素、事件的类型以及其他与特定事件相关的信息。 兼容DOM的浏览器会将一个event对象传入到事件处理程序中，无论指定事件处理程序时使用什么方法，都会传入一个event对象： 1234var btn = document.getElementById(&apos;myBtn&apos;);btn.onclick.function (event) &#123; alert(event.type); //&apos;click&apos;&#125; 上面的事件处理程序会弹出一个警告框，框中显示有event.type属性表示的事件类型。 当然，event对象上包含很多特定的属性和方法，这里只列出一个我们会用到的属性，那就是target属性，这个属性表明了我们的事件的目标。 当然，上面说的是通用的现代浏览器的event对象，当这个对象存在与IE中的时候，又不一样了： 在使用DOM0级方法添加事件处理程序的时候，event对象是作为window对象的一个属性存在的，看下面的例子： 12345var btn = document.getElementById(&apos;myBtn&apos;);btn.onclick.function () &#123; var event = window.event; alert(event.type); //&apos;click&apos;&#125; 如上面所见，我们通过window.event取得了event对象，并检测了被触发事件的类型。 那么在IE中的target属性又是什么样的呢？其实差不多，不过是target属性被替换成了srcElement属性来表示事件的目标，但是因为事件处理程序的作用域是根据指定它的方式来确定的，因此不能认为this会始终等于时间目标，所以最好使用window.event.srcElement来最终确定事件的目标！ 因此，一个兼容IE的事件目标的函数如下： 12345oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; // 程序 &#125; 事件委托： 什么是事件委托呢？书上的原话是：“事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件”，简单点解释的话，就是假如我们有一个列表，如下： 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 如果需要每个li点击之后display为none，那么传统的做法是用一个for循环遍历每一个li节点，然后在循环里面给每一个li都绑定上一个click事件； 而使用事件委托呢？就是给ul添加一个onclick的事件处理程序。。。看到这里或许就要问了，我给ul添加点击事件，那岂不是在ul里面随便点击一下就会触发了？确实如此，所以这里要进行很重要的一步：判断我们点击的到底是什么，然后再根据我们获知的点击对象去执行对应的函数。 那么如何去判断我们点击了什么呢？ 首先要用到一个我们平时在绑定事件的时候都会禁止掉的一个东西：事件冒泡。试想一下如果ul和li上都绑定了点击事件，同时li上绑定的事件没有禁止掉事件冒泡，那么当我们点击li的时候就会先触发li上的点击事件然后再触发ul上的点击事件了。同理，我们可以通过冒泡来获取click事件再执行ul上的事件处理程序。 其次，我们需要判断冒泡上来的事件流是否是在li上面触发的，如果随便一个都能冒泡并触发ul上的点击事件那也没什么意义了。这里就要用到我们上面提到的事件目标对象的获取了，通过检测我们获取到的目标的nodeName，看其是不是li就可以了。 最终的事件委托代码如下： 1234567891011var oUl = document.getElementById(&quot;ul&quot;);oUl.onclick = function(ev)&#123;var ev = ev || window.event, target = ev.target || ev.srcElement;// 因为nodeName获取到的节点名是大写，因此需要使用toLowerCase()来将其转换为小写if (target.nodeName.toLowerCase() == &quot;li&quot;) &#123; //执行函数&#125; &#125; 二、函数节流：DOM操作是昂贵的，嗯，所以FB搞了个Virtual DOM来尽量简化你的DOM操作，《高性能javascript》一书也强调了要尽量减少DOM操作~嗯，为什么要提到这个呢？ 相信很多人都用过两个事件：onresize跟onscroll，这两个事件一个在页面放大缩小时触发一个在页面滚动时触发，一般情况下伴随着这两个事件的肯定是DOM节点的定位啊，scrollTop距离的检测啊之类的操作，回到最初的问题，都说了DOM操作是很昂贵的你还在每一次onresize跟onscroll事件触发的时候去执行DOM操作，浪费机器性能很好玩么！ 既然发现了问题，那么就要解决问题，解决的办法就是函数节流。函数节流背后的思想很简单：因为onresize跟onscroll这类事件是连续不断的触发的，那么在每次触发的时候我们就开一个定时器，将DOM操作延迟，然后在下一次事件触发的时候，我们把这个定时器给关掉，这样的结果就是onresize事件一路触发的时候，我们开定时器，关定时器，开定时器，关定时器。。。一直等到最后你不执行onresize的操作了，再等待延迟的时间后，最后这个没有被关闭的定时器开始执行回调函数，访问DOM节点。 对于函数节流，有两种实现的方法： 123456789第一种是《javascript高级程序设计》中的方法：function throttle(method , context)&#123; clearTimeout(method.tId);method.tId=setTimeout(function()&#123; method.call(context);&#125;,500);&#125; 第二种是网上的方法： 12345678910111213function throttle(method , delay)&#123; var timer=null;return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; method.apply(context , args); &#125; , delay);&#125;&#125; 三、函数防抖：函数节流是一个很好用的方案，但假如我并不希望每次都是要事件结束后等待delay的事件后才执行回调，但是又希望减少DOM操作，那该如何处理呢？ 我们先给定一个时间段duration，过了这个时间段以后我们执行相应的操作，如果没有过这个时间段，那么就按照函数节流的思路，开关定时器就行了~ 123456789101112131415161718192021222324function throttle(method , duration ，delay )&#123; var timer = null, // 记录下开始执行函数的时间 begin = new Date();return function()&#123; var context = this, args = arguments, // 记录下当前时间 current = new Date(); // 函数节流里的思路 clearTimeout(timer); // 记录下的两个时间相减再与duration进行比较 if(current-begin &gt;= duration)&#123; method.apply(context , args); begin = current; &#125;else&#123; timer = setTimeout(function()&#123; method.apply(context , args); &#125; , delay); &#125;&#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"}]},{"title":"target","date":"2017-03-05T03:31:07.000Z","path":"2017/03/05/target/","text":"js中重要的三个问题 ##问题 #1: 事件委托 愚人码头注：也叫事件委派，时间代理等； 当构建应用程序时，有时你需要将事件监听器绑定到页面上的按钮，文本或图像上，以便在用户与元素交互时执行某些操作。 如果我们以一个简单的待办事项列表为例，面试官可能会告诉你，他们希望在用户单击其中一个列表项时需要执行某些操作。 他们希望你用 JavaScript 实现这个功能，假设HTML代码如下： HTML 代码: &lt;ul id=&quot;todo-app&quot;&gt; &lt;li class=&quot;item&quot;&gt;Walk the dog&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Pay bills&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Make dinner&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Code for one hour&lt;/li&gt; &lt;/ul&gt; 你可能会想像下面这样在元素绑定事件监听器： JavaScript 代码: document.addEventListener(&apos;DOMContentLoaded&apos;, function() { let app = document.getElementById(&apos;todo-app&apos;); let items = app.getElementsByClassName(&apos;item&apos;); // 将事件侦听器绑定到每个列表项 for (let item of items) { item.addEventListener(&apos;click&apos;, function() { alert(&apos;you clicked on item: &apos; + item.innerHTML); }); } }); 虽然这个实现了功能，问题是您要单独将事件侦听器绑定到每个列表项。这是4个元素，没什么大问题，但如果有人在他们的待办事项列表中添加了10,000个事项（他们可能有很多事情要做）怎么办？然后你的函数将创建 10,000 个独立的事件监听器，并将每个事件监听器绑定到 DOM 。这样代码执行的效率非常低下。 在面试中，最好首先询问面试官用户可以输入事项的最大数量是多少。如果它永远不会超过 10 个，上面的代码将工作正常。但是，如果用户可以输入的事项数量没有限制，那么你应该使用一个更高效的解决方案。 如果你的应用程序最终可能有几百个事件监听器，更高效的解决方案是将一个事件侦听器实际绑定到整个容器上，然后在实际单击时可以访问每个确切元素。这被称为事件委托，并且它每个元素单独绑定事件处理程序更高效。 用事件委托的代码： JavaScript 代码: document.addEventListener(&apos;DOMContentLoaded&apos;, function() { let app = document.getElementById(&apos;todo-app&apos;); // 事件侦听器绑定到整个容器上 app.addEventListener(&apos;click&apos;, function(e) { if (e.target &amp;&amp; e.target.nodeName === &apos;LI&apos;) { let item = e.target; alert(&apos;you clicked on item: &apos; + item.innerHTML); } }); }); ##问题 #2: 在循环内使用闭包（Closures） 闭包常常在面试中出现，以便面试官衡量你对这门语言的熟悉程度，以及是否知道何时使用闭包。 闭包的本质是一个内部函数访问其作用域之外的变量。闭包可以用于实现诸如 私有变量 和 创建工厂函数之类的东西。关于使用闭包的常见面试问题是这样的： 编写一个函数，它将循环遍历整数列表，并在3秒延迟后打印每个元素的索引。 我看到这个问题的最常见（但是不正确）是像下面这样的实现： JavaScript 代码: const arr = [10, 12, 15, 21]; for (var i = 0; i &lt; arr.length; i++) { setTimeout(function() { console.log(&apos;The index of this number is: &apos; + i); }, 3000); } 如果运行上面代码，3秒延迟后你会看到，实际上每次打印输出是4，而不是期望的0，1，2，3 。 为了正确理解为什么会发生这种情况，在JavaScript中很有用，这正是面试官真正的意图。 其原因是因为 setTimeout 函数创建了一个可以访问其外部作用域的函数（也就是我们经常说的闭包）,每个循环都包含了索引i。3秒后，该函数被执行并且打印出i的值，其在循环结束时为4，因为它的循环周期经历了0,1,2,3,4，并且循环最终在4时停止。 实际有几种 正确的写法来解决这个问题，下面列举两种： JavaScript 代码: const arr = [10, 12, 15, 21]; for (var i = 0; i &lt; arr.length; i++) { // 通过传递变量 i // 在每个函数中都可以获取到正确的索引 setTimeout(function(i_local) { return function() { console.log(&apos;The index of this number is: &apos; + i_local); } }(i), 3000); } JavaScript 代码: const arr = [10, 12, 15, 21]; for (let i = 0; i &lt; arr.length; i++) { // 使用ES6的let语法，它会创建一个新的绑定 // 每个方法都是被单独调用的 // 更多详细信息请阅读: http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads setTimeout(function() { console.log(&apos;The index of this number is: &apos; + i); }, 3000); } ##问题 #3: 函数防抖动（Debouncing） 有一些浏览器事件可以在很短的时间内快速启动多次，例如调整窗口大小或向下滚动页面。例如，如果将事件侦听器绑定到窗口滚动事件上，并且用户继续非常快速地向下滚动页面，你的事件可能会在3秒的范围内被触发数千次。这可能会导致一些严重的性能问题。 如果你在面试中讨论构建应用程序和事件，如滚动，窗口调整大小，或键盘按下的事件时，请务必提及 函数防抖动(Debouncing) 和/或 函数节流（Throttling）来提升页面速度和性能。一个真实的案例，来自 guest post on css-tricks: 在2011年，一个问题在Twitter上被提出：当你滚动Twitter feed时，它会会变得非常慢甚至未响应。John Resig 就这个问题发布了一篇博文，它解释了直接绑定函数到scroll事件上是多么糟糕的事。 函数防抖动(Debouncing) 是解决这个问题的一种方式，通过限制需要经过的时间，直到再次调用函数。一个正确实现函数防抖的方法是：把多个函数放在一个函数里调用，隔一定时间执行一次。这里有一个使用原生JavaScript实现的例子，用到了作用域、闭包、this和定时事件： JavaScript 代码: // debounce函数用来包裹我们的事件 function debounce(fn, delay) { // 持久化一个定时器 timer let timer = null; // 闭包函数可以访问 timer return function() { // 通过 &apos;this&apos; 和 &apos;arguments&apos; // 获得函数的作用域和参数 let context = this; let args = arguments; // 如果事件被触发，清除 timer 并重新开始计时 clearTimeout(timer); timer = setTimeout(function() { fn.apply(context, args); }, delay); } } 当这个函数绑定在一个事件上，只有经过一段指定的时间后才会被调用。 你可以像这样去使用这个函数： JavaScript 代码: // 当用户滚动时函数会被调用 function foo() { console.log(&apos;You are scrolling!&apos;); } // 在事件触发的两秒后，我们包裹在debounce中的函数才会被触发 let elem = document.getElementById(&apos;container&apos;); elem.addEventListener(&apos;scroll&apos;, debounce(foo, 2000)); 函数节流是另一个类似函数防抖的技巧，除了使用等待一段时间再调用函数的方法，函数节流还限制固定时间内只能调用一次。所以一个事件如果在100毫秒内发生10次，函数节流会每2秒调用一次函数，而不是100毫秒内全部调用。 想了解更多关于函数防抖和函数节流的信息，下面的文章和教程可能会帮到你： 在JavaScript中使用函数防抖和函数节流 函数节流和函数防抖的区别 实例解析防抖动（Debouncing）和节流阀（Throttling） Remy Sharp的博文节流函数的调用 翻译自： 3 JavaScript questions to watch out for during coding interviews js中重要的三个问题问题 #1: 事件委托 愚人码头注：也叫事件委派，时间代理等； 当构建应用程序时，有时你需要将事件监听器绑定到页面上的按钮，文本或图像上，以便在用户与元素交互时执行某些操作。 如果我们以一个简单的待办事项列表为例，面试官可能会告诉你，他们希望在用户单击其中一个列表项时需要执行某些操作。 他们希望你用 JavaScript 实现这个功能，假设HTML代码如下： HTML 代码: Walk the dog Pay bills Make dinner Code for one hour 你可能会想像下面这样在元素绑定事件监听器： JavaScript 代码: document.addEventListener(‘DOMContentLoaded’, function() { let app = document.getElementById(‘todo-app’); let items = app.getElementsByClassName(‘item’); // 将事件侦听器绑定到每个列表项 for (let item of items) { item.addEventListener(‘click’, function() { alert(‘you clicked on item: ‘ + item.innerHTML); }); } }); 虽然这个实现了功能，问题是您要单独将事件侦听器绑定到每个列表项。这是4个元素，没什么大问题，但如果有人在他们的待办事项列表中添加了10,000个事项（他们可能有很多事情要做）怎么办？然后你的函数将创建 10,000 个独立的事件监听器，并将每个事件监听器绑定到 DOM 。这样代码执行的效率非常低下。 在面试中，最好首先询问面试官用户可以输入事项的最大数量是多少。如果它永远不会超过 10 个，上面的代码将工作正常。但是，如果用户可以输入的事项数量没有限制，那么你应该使用一个更高效的解决方案。 如果你的应用程序最终可能有几百个事件监听器，更高效的解决方案是将一个事件侦听器实际绑定到整个容器上，然后在实际单击时可以访问每个确切元素。这被称为事件委托，并且它每个元素单独绑定事件处理程序更高效。 用事件委托的代码： JavaScript 代码: document.addEventListener(‘DOMContentLoaded’, function() { let app = document.getElementById(‘todo-app’); // 事件侦听器绑定到整个容器上 app.addEventListener(‘click’, function(e) { if (e.target &amp;&amp; e.target.nodeName === ‘LI’) { let item = e.target; alert(‘you clicked on item: ‘ + item.innerHTML); } }); }); 问题 #2: 在循环内使用闭包（Closures） 闭包常常在面试中出现，以便面试官衡量你对这门语言的熟悉程度，以及是否知道何时使用闭包。 闭包的本质是一个内部函数访问其作用域之外的变量。闭包可以用于实现诸如 私有变量 和 创建工厂函数之类的东西。关于使用闭包的常见面试问题是这样的： 编写一个函数，它将循环遍历整数列表，并在3秒延迟后打印每个元素的索引。 我看到这个问题的最常见（但是不正确）是像下面这样的实现： JavaScript 代码: const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) { setTimeout(function() { console.log(‘The index of this number is: ‘ + i); }, 3000);} 如果运行上面代码，3秒延迟后你会看到，实际上每次打印输出是4，而不是期望的0，1，2，3 。 为了正确理解为什么会发生这种情况，在JavaScript中很有用，这正是面试官真正的意图。 其原因是因为 setTimeout 函数创建了一个可以访问其外部作用域的函数（也就是我们经常说的闭包）,每个循环都包含了索引i。3秒后，该函数被执行并且打印出i的值，其在循环结束时为4，因为它的循环周期经历了0,1,2,3,4，并且循环最终在4时停止。 实际有几种 正确的写法来解决这个问题，下面列举两种： JavaScript 代码: const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) { // 通过传递变量 i // 在每个函数中都可以获取到正确的索引 setTimeout(function(i_local) { return function() { console.log(‘The index of this number is: ‘ + i_local); } }(i), 3000);} JavaScript 代码: const arr = [10, 12, 15, 21];for (let i = 0; i &lt; arr.length; i++) { // 使用ES6的let语法，它会创建一个新的绑定 // 每个方法都是被单独调用的 // 更多详细信息请阅读: http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads setTimeout(function() { console.log(‘The index of this number is: ‘ + i); }, 3000);} 问题 #3: 函数防抖动（Debouncing） 有一些浏览器事件可以在很短的时间内快速启动多次，例如调整窗口大小或向下滚动页面。例如，如果将事件侦听器绑定到窗口滚动事件上，并且用户继续非常快速地向下滚动页面，你的事件可能会在3秒的范围内被触发数千次。这可能会导致一些严重的性能问题。 如果你在面试中讨论构建应用程序和事件，如滚动，窗口调整大小，或键盘按下的事件时，请务必提及 函数防抖动(Debouncing) 和/或 函数节流（Throttling）来提升页面速度和性能。一个真实的案例，来自 guest post on css-tricks: 在2011年，一个问题在Twitter上被提出：当你滚动Twitter feed时，它会会变得非常慢甚至未响应。John Resig 就这个问题发布了一篇博文，它解释了直接绑定函数到scroll事件上是多么糟糕的事。 函数防抖动(Debouncing) 是解决这个问题的一种方式，通过限制需要经过的时间，直到再次调用函数。一个正确实现函数防抖的方法是：把多个函数放在一个函数里调用，隔一定时间执行一次。这里有一个使用原生JavaScript实现的例子，用到了作用域、闭包、this和定时事件： JavaScript 代码: // debounce函数用来包裹我们的事件function debounce(fn, delay) { // 持久化一个定时器 timer let timer = null; // 闭包函数可以访问 timer return function() { // 通过 ‘this’ 和 ‘arguments’ // 获得函数的作用域和参数 let context = this; let args = arguments; // 如果事件被触发，清除 timer 并重新开始计时 clearTimeout(timer); timer = setTimeout(function() { fn.apply(context, args); }, delay); }} 当这个函数绑定在一个事件上，只有经过一段指定的时间后才会被调用。 你可以像这样去使用这个函数： JavaScript 代码: // 当用户滚动时函数会被调用function foo() { console.log(‘You are scrolling!’);} // 在事件触发的两秒后，我们包裹在debounce中的函数才会被触发let elem = document.getElementById(‘container’);elem.addEventListener(‘scroll’, debounce(foo, 2000)); 函数节流是另一个类似函数防抖的技巧，除了使用等待一段时间再调用函数的方法，函数节流还限制固定时间内只能调用一次。所以一个事件如果在100毫秒内发生10次，函数节流会每2秒调用一次函数，而不是100毫秒内全部调用。 想了解更多关于函数防抖和函数节流的信息，下面的文章和教程可能会帮到你： 在JavaScript中使用函数防抖和函数节流函数节流和函数防抖的区别实例解析防抖动（Debouncing）和节流阀（Throttling）Remy Sharp的博文节流函数的调用 翻译自： 3 JavaScript questions to watch out for during coding interviews","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"}]},{"title":"json和jsonp","date":"2017-03-02T15:15:23.000Z","path":"2017/03/02/json和jsonp/","text":"json和jsonp 前言： 说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。 但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。 JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。 既然随便聊聊，那我们就不再采用教条的方式来讲述，而是把关注重心放在帮助开发人员理解是否应当选择使用以及如何使用上。 什么是JSON？前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。 JSON的优点：1、基于纯文本，跨平台传递极其简单； 2、Javascript原生支持，后台语言几乎全部支持； 3、轻量级数据格式，占用字符数量极少，特别适合互联网传递； 4、可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的； 5、容易编写和解析，当然前提是你要知道数据结构； JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。 JSON的格式或者叫规则： JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。 1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号”“是定义符。 2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。 3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。 4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号”“，以便于不同语言的解析。 5、JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。 JSON实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 描述一个人var person = &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true&#125;// 获取这个人的信息var personAge = person.Age;// 描述几个人var members = [ &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true &#125;, &#123; &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false &#125;, &#123; &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false &#125;]// 读取其中John的公司名称var johnsCompany = members[1].Company;// 描述一次会议var conference = &#123; &quot;Conference&quot;: &quot;Future Marketing&quot;, &quot;Date&quot;: &quot;2012-6-1&quot;, &quot;Address&quot;: &quot;Beijing&quot;, &quot;Members&quot;: [ &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true &#125;, &#123; &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false &#125;, &#123; &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false &#125; ]&#125;// 读取参会者Henry是否工程师var henryIsAnEngineer = conference.Members[2].Engineer; 关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。 什么是JSONP？先说说JSONP是怎么产生的： 其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。 1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如 JSONP的客户端具体实现：不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现： 1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。 远程服务器remoteserver.com根目录下有个remote.js文件代码如下： alert(‘我是远程文件’); 本地服务器localserver.com下有个jsonp.html页面代码如下：复制代码 12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。 jsonp.html页面代码如下：复制代码 123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data)&#123; alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); &#125;; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; remote.js文件代码如下： 1localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;); 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。 看jsonp.html页面的代码：复制代码 1234567891011121314151617&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 12345flightHandler(&#123; &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：复制代码 123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt; &lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？ 没想到上了博客园的头条推荐。看到大家对这篇文章的认可和评论，还是很开心的，这里针对ajax与jsonp的异同再做一些补充说明： 1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ 转自http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"},{"name":"json","slug":"json","permalink":"ZYLZYL.github.io/tags/json/"},{"name":"jsonp","slug":"jsonp","permalink":"ZYLZYL.github.io/tags/jsonp/"}]},{"title":"前端基础进阶（一）：内存空间详细图解 ","date":"2017-03-02T08:15:55.000Z","path":"2017/03/02/前端基础进阶（一）：内存空间详细图解/","text":"前端基础进阶（一）：内存空间详细图解 变量对象与堆内存1234567var a = 20;var b = &apos;abc&apos;;var c = true;var d = &#123; m: 20 &#125; 因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不是计算机专业的朋友在进入到前端之后，会对内存空间的认知比较模糊，甚至有些人干脆就是一无所知。 当然也包括我自己。在很长一段时间里认为内存空间的概念在JS的学习中并不是那么重要。可是后我当我回过头来重新整理JS基础时，发现由于对它们的模糊认知，导致了很多东西我都理解得并不明白。比如最基本的引用数据类型和引用传递到底是怎么回事儿？比如浅复制与深复制有什么不同？还有闭包，原型等等。 因此后来我才渐渐明白，想要对JS的理解更加深刻，就必须对内存空间有一个清晰的认知。 一、栈与堆 注：栈，也可以叫堆栈 与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以粗浅的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思路进行处理，比如JavaScript的执行上下文（关于执行上下文我会在下一篇文章中总结）。执行上下文在逻辑上实现了堆栈。因此理解堆栈数据结构的原理与特点任然十分重要。 要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图左侧。 ​ 乒乓球盒子与栈类比 这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。图中已经详细的表明了栈空间的存储原理。 堆存取数据的方式，则与书架与书非常相似。 书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。 二、变量对象与基础数据类型JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象（具体会在下一篇文章与执行上下文一起总结），JavaScript的基础数据类型往往都会保存在变量对象中。 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。 基础数据类型都是一些简单的数据段，JavaScript中有5中基础数据类型，分别是Undefined、Null、Boolean、Number、String。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。 三、引用数据类型与堆内存与其他语言不通，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 1234567891011var a1 = 0; // 变量对象var a2 = &apos;this is string&apos;; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 ​ 上例图解 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。 理解了JS的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。 在前端面试中我们常常会遇到这样一个类似的题目 12345678910111213141516171819202122232425// demo01.jsvar a = 20;var b = a;b = 30;// 这时a的值是多少？// demo02.jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 15;// 这时m.a的值是多少 在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var b = a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。 ​ demo01图解 在demo02中，我们通过var n = m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。 因此当我改变n时，m也发生了变化。这就是引用类型的特性。 ​ demo02图解 通过内存的角度来理解，是不是感觉要轻松很多。除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。其他的我会在以后的文章慢慢总结，敬请期待。 内存空间管理 因为JavaScript具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理。但是根据我自己的开发经验，了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。因此关心内存是一件非常重要的事情。 JavaScript的内存生命周期 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放、归还 为了便于理解，我们使用一个简单的例子来解释这个周期。 12345var a = 20; // 在内存中给数值变量分配空间alert(a + 100); // 使用内存a = null; // 使用完毕之后，释放内存空间 第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。 JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。 要详细了解垃圾收集机制，建议阅读《JavaScript高级编程》中的4.3节","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"}]},{"title":"10大经典排序","date":"2017-03-02T04:15:52.000Z","path":"2017/03/02/10大经典排序/","text":"十大经典排序 冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 1. 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2. 动图演示 3. 什么时候最快当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 4. 什么时候最慢当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 5. JavaScript 代码实现12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 6. Python 代码实现123456def bubbleSort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] &gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr 7. Go 代码实现1234567891011func bubbleSort(arr []int) []int &#123; length := len(arr) for i := 0; i &lt; length; i++ &#123; for j := 0; j &lt; length-1-i; j++ &#123; if arr[j] &gt; arr[j+1] &#123; arr[j], arr[j+1] = arr[j+1], arr[j] &#125; &#125; &#125; return arr&#125; 选择排序选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 1. 算法步骤首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 2. 动图演示动图演示 3. JavaScript 代码实现12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 4. Python 代码实现123456def selectionSort(arr): for i in range(len(arr)-1): for j in range(i+1, len(arr)): if arr[j] &lt; arr[i]: arr[i], arr[j] = arr[j], arr[i] return arr 5. Go 代码实现12345678910111213func selectionSort(arr []int) []int &#123; length := len(arr) for i := 0; i &lt; length-1; i++ &#123; min := i for j := i + 1; j &lt; length; j++ &#123; if arr[min] &gt; arr[j] &#123; min = j &#125; &#125; arr[i], arr[min] = arr[min], arr[i] &#125; return arr&#125; 插入排序插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 1. 算法步骤将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 2. 动图演示动图演示 3. JavaScript 代码实现1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 4. Python 代码实现123456789def insertionSort(arr): for i in range(len(arr)): preIndex = i-1 current = arr[i] while preIndex &gt;= 0 and arr[preIndex] &gt; current: arr[preIndex+1] = arr[preIndex] preIndex-=1 arr[preIndex+1] = current return arr 5. Go 代码实现123456789101112func insertionSort(arr []int) []int &#123; for i := range arr &#123; preIndex := i - 1 current := arr[i] for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current &#123; arr[preIndex+1] = arr[preIndex] preIndex -= 1 &#125; arr[preIndex+1] = current &#125; return arr&#125; 希尔排序 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；​ 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 1. 算法步骤选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2. JavaScript 代码实现123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap =gap*3+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 3. Python 代码实现12345678910111213141516def shellSort(arr): import math gap=1 while(gap &lt; len(arr)/3): gap = gap*3+1 while gap &gt; 0: for i in range(gap,len(arr)): temp = arr[i] j = i-gap while j &gt;=0 and arr[j] &gt; temp: arr[j+gap]=arr[j] j-=gap arr[j+gap] = temp gap = math.floor(gap/3) return arr&#125; 4. Go 代码实现1234567891011121314151617181920func shellSort(arr []int) []int &#123; length := len(arr) gap := 1 for gap &lt; gap/3 &#123; gap = gap*3 + 1 &#125; for gap &gt; 0 &#123; for i := gap; i &lt; length; i++ &#123; temp := arr[i] j := i - gap for j &gt;= 0 &amp;&amp; arr[j] &gt; temp &#123; arr[j+gap] = arr[j] j -= gap &#125; arr[j+gap] = temp &#125; gap = gap / 3 &#125; return arr&#125; 归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；​ 自下而上的迭代； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 2. 算法步骤申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；​ 重复步骤 3 直到某一指针达到序列尾；​ 将另一序列剩下的所有元素直接复制到合并序列尾。 3. 动图演示动图演示 4. JavaScript 代码实现12345678910111213141516171819202122232425262728293031function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = [];while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125;&#125;while (left.length) result.push(left.shift());while (right.length) result.push(right.shift());return result;&#125; 5. Python 代码实现1234567891011121314151617181920def mergeSort(arr): import math if(len(arr)&lt;2): return arr middle = math.floor(len(arr)/2) left, right = arr[0:middle], arr[middle:] return merge(mergeSort(left), mergeSort(right))def merge(left,right): result = [] while left and right: if left[0] &lt;= right[0]: result.append(left.pop(0)); else: result.append(right.pop(0)); while left: result.append(left.pop(0)); while right: result.append(right.pop(0)); return result 6. Go 代码实现1234567891011121314151617181920212223242526272829303132333435func mergeSort(arr []int) []int &#123; length := len(arr) if length &lt; 2 &#123; return arr &#125; middle := length / 2 left := arr[0:middle] right := arr[middle:] return merge(mergeSort(left), mergeSort(right))&#125;func merge(left []int, right []int) []int &#123; var result []int for len(left) != 0 &amp;&amp; len(right) != 0 &#123; if left[0] &lt;= right[0] &#123; result = append(result, left[0]) left = left[1:] &#125; else &#123; result = append(result, right[0]) right = right[1:] &#125; &#125; for len(left) != 0 &#123; result = append(result, left[0]) left = left[1:] &#125; for len(right) != 0 &#123; result = append(result, right[0]) right = right[1:] &#125; return result&#125; 快速排序快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 1. 算法步骤从数列中挑出一个元素，称为 “基准”（pivot）;​ 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 2. 动图演示动图演示 3. JavaScript 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != &apos;number&apos; ? 0 : left, right = typeof right != &apos;number&apos; ? len - 1 : right;if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right);&#125;return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;functiion paritition2(arr, low, high) &#123; let pivot = arr[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123; --high; &#125; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123; ++low; &#125; arr[high] = arr[low]; &#125; arr[low] = pivot; return low;&#125;function quickSort2(arr, low, high) &#123; if (low &lt; high) &#123; let pivot = paritition2(arr, low, high); quickSort2(arr, low, pivot - 1); quickSort2(arr, pivot + 1, high); &#125; return arr;&#125; 4. Python 代码实现1234567891011121314151617181920212223def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left &lt; right: partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) return arrdef partition(arr, left, right): pivot = left index = pivot+1 i = index while i &lt;= right: if arr[i] &lt; arr[pivot]: swap(arr, i, index) index+=1 i+=1 swap(arr,pivot,index-1) return index-1def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] 5. Go 代码实现123456789101112131415161718192021222324252627282930func quickSort(arr []int) []int &#123; return _quickSort(arr, 0, len(arr)-1)&#125;func _quickSort(arr []int, left, right int) []int &#123; if left &lt; right &#123; partitionIndex := partition(arr, left, right) _quickSort(arr, left, partitionIndex-1) _quickSort(arr, partitionIndex+1, right) &#125; return arr&#125;func partition(arr []int, left, right int) int &#123; pivot := left index := pivot + 1 for i := index; i &lt;= right; i++ &#123; if arr[i] &lt; arr[pivot] &#123; swap(arr, i, index) index += 1 &#125; &#125; swap(arr, pivot, index-1) return index - 1&#125;func swap(arr []int, i, j int) &#123; arr[i], arr[j] = arr[j], arr[i]&#125; 6. C++版12345678910111213141516171819202122232425//严蔚敏《数据结构》标准分割函数Paritition1(int A[], int low, int high) &#123; int pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; --high; &#125; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;void QuickSort(int A[], int low, int high) //快排母函数&#123; if (low &lt; high) &#123; int pivot = Paritition1(A, low, high); QuickSort(A, low, pivot - 1); QuickSort(A, pivot + 1, high); &#125;&#125; 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 1. 算法步骤1234567创建一个堆 H[0……n-1]；把堆首（最大值）和堆尾互换；把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；重复步骤 2，直到堆的尺寸为 1。 2. 动图演示动图演示 3. JavaScript 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i;if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left;&#125;if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right;&#125;if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest);&#125;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125; 4. Python 代码实现123456789101112131415161718192021222324252627282930def buildMaxHeap(arr): import math for i in range(math.floor(len(arr)/2),-1,-1): heapify(arr,i)def heapify(arr, i): left = 2*i+1 right = 2*i+2 largest = i if left &lt; arrLen and arr[left] &gt; arr[largest]: largest = left if right &lt; arrLen and arr[right] &gt; arr[largest]: largest = right if largest != i: swap(arr, i, largest) heapify(arr, largest)def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i]def heapSort(arr): global arrLen arrLen = len(arr) buildMaxHeap(arr) for i in range(len(arr)-1,0,-1): swap(arr,0,i) arrLen -=1 heapify(arr, 0) return arr 5. Go 代码实现123456789101112131415161718192021222324252627282930313233343536func heapSort(arr []int) []int &#123; arrLen := len(arr) buildMaxHeap(arr, arrLen) for i := arrLen - 1; i &gt;= 0; i-- &#123; swap(arr, 0, i) arrLen -= 1 heapify(arr, 0, arrLen) &#125; return arr&#125;func buildMaxHeap(arr []int, arrLen int) &#123; for i := arrLen / 2; i &gt;= 0; i-- &#123; heapify(arr, i, arrLen) &#125;&#125;func heapify(arr []int, i, arrLen int) &#123; left := 2*i + 1 right := 2*i + 2 largest := i if left &lt; arrLen &amp;&amp; arr[left] &gt; arr[largest] &#123; largest = left &#125; if right &lt; arrLen &amp;&amp; arr[right] &gt; arr[largest] &#123; largest = right &#125; if largest != i &#123; swap(arr, i, largest) heapify(arr, largest, arrLen) &#125;&#125;func swap(arr []int, i, j int) &#123; arr[i], arr[j] = arr[j], arr[i]&#125; 计数排序计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 1. 动图演示动图演示 2. JavaScript 代码实现12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue+1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1;for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++;&#125;for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125;&#125;return arr;&#125; 3. Python 代码实现123456789101112131415def countingSort(arr, maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 for j in range(bucketLen): while bucket[j]&gt;0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr 4. Go 代码实现123456789101112131415161718192021func countingSort(arr []int, maxValue int) []int &#123; bucketLen := maxValue + 1 bucket := make([]int, bucketLen) // 初始为0的数组sortedIndex := 0length := len(arr)for i := 0; i &lt; length; i++ &#123; bucket[arr[i]] += 1&#125;for j := 0; j &lt; bucketLen; j++ &#123; for bucket[j] &gt; 0 &#123; arr[sortedIndex] = j sortedIndex += 1 bucket[j] -= 1 &#125;&#125;return arr&#125; 桶排序桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 1. 什么时候最快当输入的数据可以均匀的分配到每一个桶中。 2. 什么时候最慢当输入的数据被分配到了同一个桶中。 3. JavaScript 代码实现12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125;var i;var minValue = arr[0];var maxValue = arr[0];for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125;&#125;//桶的初始化var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount);for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = [];&#125;//利用映射函数将数据分配到各个桶中for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);&#125;arr.length = 0;for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125;&#125;return arr;&#125; 基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 1. 基数排序 vs 计数排序 vs 桶排序基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； 2. LSD 基数排序动图演示动图演示 3. JavaScript 代码实现12345678910111213141516171819202122232425//LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"},{"name":"排序","slug":"排序","permalink":"ZYLZYL.github.io/tags/排序/"},{"name":"python","slug":"python","permalink":"ZYLZYL.github.io/tags/python/"}]},{"title":"jsvascript中的小技巧2","date":"2017-03-02T03:59:58.000Z","path":"2017/03/02/jsvascript中的小技巧2/","text":"jsvascript中的小技巧2 一、JS动画与动作不一致解决: 123if(!$( &quot;#handle&quot;).is(&quot;:animated&quot;))&#123; //判断元素是否处于动画状态&#125; 二、停止事件冒泡 12345678910event.stopPropagation();- 禁止JS报错 window.onerror = function()&#123; return true ; &#125;try &#123;/*try to do*/&#125; catch(e)&#123;/*do this if try error */&#125; 三、查看JS对象属性 1234567 var res = &apos;&apos; ; var obj = eval( obj ); for( var p in eval( obj ) )&#123; var prop = p + &apos;:&apos; + obj[p] + &apos;\\n&apos; ; res += prop ; &#125; alert( res ); 四、页面刷新时禁用提交按钮 123window.onbeforeunload = function()&#123; $(&apos;:submit&apos;).attr(&apos;disabled&apos;,true);&#125; 注意：Opera 浏览器不支持，其他浏览器避免在同一页面中使用 “javascrpt:” 等伪协议五、获取事件 123456789var getEvent = function()&#123; var ieEvent = window.event ; var ffEvent = arguments.callee.caller.arguments[0] ; //arguments.callee 当前执行函数 //arguments.callee.caller 当前执行函数的调用者 //arguments.callee.caller.arguments[0] 当前函数调用者的第一个参数 var e = ieEvent || ffEvent ; return e ;&#125; 获取鼠标距离浏览器顶部 左侧的实际距离 兼容IE 123456789101112131415161718192021function getXY(ev)&#123; var ev = ev || window.event; var xx = 0; var yy = 0; if(ev.pageX)&#123; //iE9+ xx = ev.pageX; yy = ev.pageY; &#125;else&#123; //IE678 clientX,clientY + scroll var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//IE9+ var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;//IE9+ xx = ev.clientX + scrollLeft; yy = ev.clientY + scrollTop; &#125; return &#123; x:xx, y:yy &#125;; &#125; 六、获取键盘码 1234567var getKCode = function()&#123; var ieEvent = window.event ; var ffEvent = arguments.callee.caller.arguments[0] ; var e = ieEvent || ffEvent ; var kCode = e.keyCode || e.which ; return kCode ; &#125; 七、 鼠标滑入/滑出样式切换 123$(&quot;div&quot;).on(&quot;mouseover mouseout&quot;, function()&#123; $(this).toggleClass(&quot;over&quot;); &#125;); 八、点击鼠标,显示/隐藏切换 1234567$(&quot;#panel h5.head&quot;).toggle(function()&#123; $(this).toggleClass(&quot;highlight&quot;); $(this).next().toggle();&#125;,function()&#123; $(this).toggleClass(&quot;highlight&quot;); $(this).next().toggle();&#125;); 九、JS 调试 12345console.log() ; //打印变量console.dir() ; //打印对象console.dirxml() ; //打印节点console.trace() ; //打印函数调用轨迹window.document.title = str; 十、为子元素集合绑定事件 123$(&quot;div&quot;).delegate(&quot;button&quot;,&quot;click&quot;,function()&#123; $(&quot;p&quot;).slideToggle();&#125;); 十一、自定义IE浏览器渲染方式(解决IE10下JS或插件失效): 如果安装了Chrome内核，则使用Chrome内核来渲染页面[chrome=1]，如果未安装，则使用最高版本的IE内核进行渲染[IE=edge]: 十二、注册事件 1234567891011121314// 标准浏览器form1.addEventListener(&apos;submit&apos;, function(e)&#123; e.preventDefault(); //阻止浏览器默认动作 e.stopPropagation(); //阻止事件流产生&#125;);// IE8及更早版本IE浏览器form1.attachEvent(&apos;submit&apos;, function()&#123; event.cancelBubble = true; //阻止浏览器默认动作--IE8及更早版本IE浏览器 event.returnValue = false; //阻止事件流产生--IE8及更早版本IE浏览器&#125;","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"ZYLZYL.github.io/tags/前端/"}]},{"title":"javascript中的this","date":"2017-03-02T03:54:19.000Z","path":"2017/03/02/javascript中的this/","text":"JavaScript This 的六道坎 鉴于this风骚的运作方式，对this的理解是永不过时的话题，本文试图通过将其大卸六块来钉住这个磨人的妖精。 首先 1this is all about context. this说白了就是找大佬，找拥有当前上下文（context）的对象（context object）。 大佬可以分为六层，层数越高权力越大，this只会认最大的。第一层：世界尽头 权力最小的大佬是作为备胎的存在，在普通情况下就是全局，浏览器里就是window；在use strict的情况下就是undefined。 123456789function showThis () &#123; console.log(this)&#125;function showStrictThis () &#123; &apos;use strict&apos; console.log(this)&#125;showThis() // windowshowStrictThis() // undefined 第二层：点石成金 第二层大佬说白了就是找这个函数前面的点.。 如果用到this的那个函数是属于某个 context object 的，那么这个 context object 绑定到this。 比如下面的例子，boss是returnThis的 context object ，或者说returnThis属于boss。 1234567var boss = &#123; name: &apos;boss&apos;, returnThis () &#123; return this &#125;&#125;boss.returnThis() === boss // true 下面这个例子就要小心点咯，能想出答案么？ 12345678910111213141516171819202122var boss1 = &#123; name: &apos;boss1&apos;, returnThis () &#123; return this &#125;&#125;var boss2 = &#123; name: &apos;boss2&apos;, returnThis () &#123; return boss1.returnThis() &#125;&#125;var boss3 = &#123; name: &apos;boss3&apos;, returnThis () &#123; var returnThis = boss1.returnThis return returnThis() &#125;&#125;boss1.returnThis() // boss1boss2.returnThis() // ?boss3.returnThis() // ? 答案是boss1和window哦，猜对了吗。 只要看使用this的那个函数。 在boss2.returnThis里，使用this的函数是boss1.returnThis，所以this绑定到boss1； 在boss3.returnThis里，使用this的函数是returnThis，所以this绑定到备胎。 要想把this绑定到boss2怎么做呢？ 1234567891011var boss1 = &#123; name: &apos;boss1&apos;, returnThis () &#123; return this &#125;&#125;var boss2 = &#123; name: &apos;boss2&apos;, returnThis: boss1.returnThis&#125;boss2.returnThis() //boss2 没错，只要让使用this的函数是属于boss2就行。第三层：指腹为婚 第三层大佬是Object.prototype.call和Object.prototype.apply，它们可以通过参数指定this。（注意this是不可以直接赋值的哦，this = 2会报ReferenceError。） 1234567function returnThis () &#123; return this&#125;var boss1 = &#123; name: &apos;boss1&apos; &#125;returnThis() // windowreturnThis.call(boss1) // boss1returnThis.apply(boss1) // boss1 第四层：海誓山盟 第四层大佬是Object.prototype.bind，他不但通过一个新函数来提供永久的绑定，还会覆盖第三层大佬的命令。 12345678function returnThis () &#123; return this&#125;var boss1 = &#123; name: &apos;boss1&apos;&#125;var boss1returnThis = returnThis.bind(boss1)boss1returnThis() // boss1var boss2 = &#123; name: &apos;boss2&apos; &#125;boss1returnThis.call(boss2) // still boss1 第五层：内有乾坤 一个比较容易忽略的会绑定this的地方就是new。当我们new一个函数时，就会自动把this绑定在新对象上，然后再调用这个函数。它会覆盖bind的绑定。 1234567891011function showThis () &#123; console.log(this)&#125;showThis() // windownew showThis() // showThisvar boss1 = &#123; name: &apos;boss1&apos; &#125;showThis.call(boss1) // boss1new showThis.call(boss1) // TypeErrorvar boss1showThis = showThis.bind(boss1)boss1showThis() // boss1new boss1showThis() // showThis 第六层：军令如山 最后一个法力无边的大佬就是 ES2015 的箭头函数。箭头函数里的this不再妖艳，被永远封印到当前词法作用域之中，称作 Lexical this ，在代码运行前就可以确定。没有其他大佬可以覆盖。 这样的好处就是方便让回调函数的this使用当前的作用域，不怕引起混淆。 所以对于箭头函数，只要看它在哪里创建的就行。 如果对 V8 实现的词法作用域感兴趣可以看看这里。 12345678910111213function callback (cb) &#123; cb()&#125;callback(() =&gt; &#123; console.log(this) &#125;) // windowvar boss1 = &#123; name: &apos;boss1&apos;, callback: callback, callback2 () &#123; callback(() =&gt; &#123; console.log(this) &#125;) &#125;&#125;boss1.callback(() =&gt; &#123; console.log(this) &#125;) // still windowboss1.callback2(() =&gt; &#123; console.log(this) &#125;) // boss1 下面这种奇葩的使用方式就需要注意： 12345678910111213141516171819var returnThis = () =&gt; thisreturnThis() // windownew returnThis() // TypeErrorvar boss1 = &#123; name: &apos;boss1&apos;, returnThis () &#123; var func = () =&gt; this return func() &#125;&#125;returnThis.call(boss1) // still windowvar boss1returnThis = returnThis.bind(boss1)boss1returnThis() // still windowboss1.returnThis() // boss1var boss2 = &#123; name: &apos;boss2&apos;, returnThis: boss1.returnThis&#125;boss2.returnThis() // boss2 如果你不知道最后为什么会是 boss2，继续理解“对于箭头函数，只要看它在哪里创建”这句话。","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"}]},{"title":"jsvascript中的几个小技巧","date":"2017-03-02T03:32:57.000Z","path":"2017/03/02/jsvascript中的几个小技巧/","text":"javascript初学者的7个建议 每种语言都有它特别的地方，对于JavaScript来说，使用var就可以声明任意类型的变量，这门脚本语言看起来很简单，然而想要写出优雅的代码却是需要不断积累经验的。本文利列举了JavaScript初学者应该注意的七个细节，与大家分享。 简化代码 JavaScript定义对象和数组非常简单，我们想要创建一个对象，一般是这样写的： 12345var car = new Object();car.colour = &apos;red&apos;;car.wheels = 4;car.hubcaps = &apos;spinning&apos;;car.age = 4; 下面的写法可以达到同样的效果： 123456var car = &#123; colour:&apos;red&apos;, wheels:4, hubcaps:&apos;spinning&apos;, age:4&#125; 后面的写法要短得多，而且你不需要重复写对象名称。 另外对于数组同样有简洁的写法，过去我们声明数组是这样写的： 123var moviesThatNeedBetterWriters = new Array( &apos;Transformers&apos;,&apos;Transformers2&apos;,&apos;Avatar&apos;,&apos;Indiana Jones 4&apos;); 更简洁的写法是： 123var moviesThatNeedBetterWriters = [ &apos;Transformers&apos;,&apos;Transformers2&apos;,&apos;Avatar&apos;,&apos;Indiana Jones 4&apos;]; 对于数组，还有关联数组这样一个特别的东西。 你会发现很多代码是这样定义对象的： 12345var car = new Array();car[&apos;colour&apos;] = &apos;red&apos;;car[&apos;wheels&apos;] = 4;car[&apos;hubcaps&apos;] = &apos;spinning&apos;;car[&apos;age&apos;] = 4; 这太疯狂了，不要觉得困惑，“关联数组”只是对象的一个别名而已。 另外一个简化代码的方法是使用三元运算符，举个例子： 123456var direction;if(x &lt; 200)&#123; direction = 1;&#125; else &#123; direction = -1;&#125; 我们可以使用如下的代码替换这种写法： 12345678910111213141516171819202122232425262728var direction = x &lt; 200 ? 1 : -1;使用JSON作为数据格式 伟大的Douglas Crockford发明了JSON数据格式来存储数据，你可以使用原生的javascript方法来存储复杂的数据而不需要进行任何额外的转换，例如：var band = &#123; &quot;name&quot;:&quot;The Red Hot Chili Peppers&quot;, &quot;members&quot;:[ &#123; &quot;name&quot;:&quot;caibaojian.com&quot;, &quot;role&quot;:&quot;lead vocals&quot; &#125;, &#123; &quot;name&quot;:&quot;Michael &apos;Flea&apos; Balzary&quot;, &quot;role&quot;:&quot;bass guitar, trumpet, backing vocals&quot; &#125;, &#123; &quot;name&quot;:&quot;Chad Smith&quot;, &quot;role&quot;:&quot;drums,percussion&quot; &#125;, &#123; &quot;name&quot;:&quot;John Frusciante&quot;, &quot;role&quot;:&quot;Lead Guitar&quot; &#125; ], &quot;year&quot;:&quot;2009&quot;&#125; 你可以使用在JavaScript中直接使用JSON，甚至作为API返回的一种格式，在许多的API中被应用，例如： 123456789101112&lt;div id=&quot;delicious&quot;&gt;&lt;/div&gt;&lt;script&gt;function delicious(o)&#123; var out = &apos;&lt;ul&gt;&apos;; for(var i=0;i&lt;o.length;i++)&#123; out += &apos;&lt;li&gt;&lt;a href=&quot;&apos; + o[i].u + &apos;&quot;&gt;&apos; + o[i].d + &apos;&lt;/a&gt;&lt;/li&gt;&apos;; &#125; out += &apos;&lt;/ul&gt;&apos;; document.getElementById(&apos;delicious&apos;).innerHTML = out;&#125;&lt;/script&gt;&lt;script src=&quot;http://feeds.delicious.com/v2/json/codepo8/javascript?count=15&amp;callback=delicious&quot;&gt;&lt;/script&gt; 这里调用delicious 的web服务获取最新书签，以JSON格式返回，然后将它们显示成无序列表的形式。 从本质上讲，JSON是用于描述复杂的数据最轻量级的方式，而且直接它运行在浏览器中。 你甚至可以在PHP中调用 json_decode（）函数来使用它。尽量使用JavaScript原生函数 要找一组数字中的最大数，我们可能会写一个循环，例如： 12345678var numbers = [3,342,23,22,124];var max = 0;for(var i=0;i&lt;numbers.length;i++)&#123; if(numbers[i] &gt; max)&#123; max = numbers[i]; &#125;&#125;alert(max); 其实，不用循环可以实现同样的功能： 123var numbers = [3,342,23,22,124];numbers.sort(function(a,b)&#123;return b - a&#125;);alert(numbers[0]); 而最简洁的写法是： 1Math.max(12,123,3,2,433,4); // returns 433 你甚至可以使用Math.max来检测浏览器支持哪个属性： 1234var scrollTop= Math.max( doc.documentElement.scrollTop, doc.body.scrollTop); 如果你想给一个元素增加class样式，可能原始的写法是这样的： 123function addclass(elm,newclass)&#123; var c = elm.className; elm.className = (c === &apos;&apos;) ? newclass : c+&apos; &apos;+newclass; 而更优雅的写法是： 12345function addclass(elm,newclass)&#123; var classes = elm.className.split(&apos; &apos;); classes.push(newclass); elm.className = classes.join(&apos; &apos;);&#125; 事件委托 事件是JavaScript非常重要的一部分。我们想给一个列表中的链接绑定点击事件，一般的做法是写一个循环，给每个链接对象绑定事件，HTML代码如下： 123456789&lt;h2&gt;Great Web resources&lt;/h2&gt;&lt;ul id=&quot;resources&quot;&gt; &lt;li&gt;&lt;a href=&quot;http://opera.com/wsc&quot;&gt;Opera Web Standards Curriculum&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://sitepoint.com&quot;&gt;Sitepoint&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://alistapart.com&quot;&gt;A List Apart&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://yuiblog.com&quot;&gt;YUI Blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://caibaojian.com&quot;&gt;WEB frontend blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://www.devtoutiao.com&quot;&gt;Develop news&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 脚本如下： 123456789101112131415// Classic event handling example(function()&#123; var resources = document.getElementById(&apos;resources&apos;); var links = resources.getElementsByTagName(&apos;a&apos;); var all = links.length; for(var i=0;i&lt;all;i++)&#123; // Attach a listener to each link links[i].addEventListener(&apos;click&apos;,handler,false); &#125;; function handler(e)&#123; var x = e.target; // Get the link that was clicked alert(x); e.preventDefault(); &#125;;&#125;)(); 更合理的写法是只给列表的父对象绑定事件，代码如下： 1234567891011(function()&#123; var resources = document.getElementById(&apos;resources&apos;); resources.addEventListener(&apos;click&apos;,handler,false); function handler(e)&#123; var x = e.target; // get the link tha if(x.nodeName.toLowerCase() === &apos;a&apos;)&#123; alert(&apos;Event delegation:&apos; + x); e.preventDefault(); &#125; &#125;;&#125;)(); 匿名函数 关于JavaScript的最头疼的事情之一是，它的变量没有特定的作用范围。 一般情况下，任何变量，函数，数组或对象都是全局性，这意味着在同一页上的其他脚本可以访问并覆盖它们。解决方法是把变量封装在一个匿名函数中。 例如，下面的定义将产生三个全局变量和和两个全局函数： 123456789var name = &apos;Chris&apos;;var age = &apos;34&apos;;var status = &apos;single&apos;;function createMember()&#123; // [...]&#125;function getMemberDetails()&#123; // [...]&#125; 封装后如下： 123456789101112131415var myApplication = function()&#123; var name = &apos;Chris&apos;; var age = &apos;34&apos;; var status = &apos;single&apos;; return&#123; createMember:function()&#123; // [...] &#125;, getMemberDetails:function()&#123; // [...] &#125; &#125;&#125;();// myApplication.createMember() and// myApplication.getMemberDetails() now works. 这被称为单体模式，是JavaScript设计模式的一种，这种模式在YUI中用得非常多，改进的写法是： 12345678910111213141516var myApplication = function()&#123; var name = &apos;Chris&apos;; var age = &apos;34&apos;; var status = &apos;single&apos;; function createMember()&#123; // [...] &#125; function getMemberDetails()&#123; // [...] &#125; return&#123; create:createMember, get:getMemberDetails &#125;&#125;();//myApplication.get() and myApplication.create() now work. 代码可配置 你写的代码如果想让别人更容易进行使用或者修改，则需要可配置，解决方案是在你写的脚本中增加一个配置对象。要点如下： 1、在你的脚本中新增一个叫configuration的对象。 2、在配置对象中存放所有其它人可能想要去改变的东西，例如CSS的ID、class名称、语言等等。 3、返回这个对象，作为公共属性以便其它人可以进行重写。代码兼容性 兼容性是初学者容易忽略的部分，通常学习Javascript的时候都是在某个固定的浏览器中进行测试，而这个浏览器很有可能就是IE，这是非常致命的，因为目前几大主流浏览器中偏偏IE对标准的支持是最差的。最终用户看到的结果也许就是，你写的代码在某个浏览器无法正确运行。你应该把你的代码在主流的浏览器中都测试一下，这也许很费时间，但是应该这样做。","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"}]},{"title":"javascript中的一些题目","date":"2017-03-01T14:41:06.000Z","path":"2017/03/01/javascript中的一些题目/","text":"javascript中的一些题目 1、使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)： 123456let obj = &#123;&#125;;let arr = [];console.log(typeof obj === &apos;object&apos;); //trueconsole.log(typeof arr === &apos;object&apos;); //trueconsole.log(typeof null === &apos;object&apos;); //true 从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端： 123456let obj = &#123;&#125;;let arr = [];console.log(Object.prototype.toString.call(obj)); //[object Object]console.log(Object.prototype.toString.call(arr)); //[object Array]console.log(Object.prototype.toString.call(null)); //[object Null] 另外，为了珍爱生命，请远离 ==：珍爱生命 而 [] === false 是返回 false 的。 2、下面的代码会在 console 输出神马？为什么？123456(function()&#123; var a = b = 3;&#125;)();console.log(&quot;a defined? &quot; + (typeof a !== &apos;undefined&apos;)); console.log(&quot;b defined? &quot; + (typeof b !== &apos;undefined&apos;)); 这跟变量作用域有关，输出换成下面的： 12console.log(b); //3console,log(typeof a); //undefined 拆解一下自执行函数中的变量赋值： 12b = 3;var a = b; 所以 b 成了全局变量，而 a 是自执行函数的一个局部变量。 3、下面的代码会在 console 输出神马？为什么？12345678910111213var myObject = &#123; foo: &quot;bar&quot;, func: function() &#123; var self = this; console.log(&quot;outer func: this.foo = &quot; + this.foo); console.log(&quot;outer func: self.foo = &quot; + self.foo); (function() &#123; console.log(&quot;inner func: this.foo = &quot; + this.foo); console.log(&quot;inner func: self.foo = &quot; + self.foo); &#125;()); &#125;&#125;;myObject.func(); 第一个和第二个的输出不难判断，在 ES6 之前，JavaScript 只有函数作用域，所以 func 中的 IIFE 有自己的独立作用域，并且它能访问到外部作用域中的 self，所以第三个输出会报错，因为 this 在可访问到的作用域内是 undefined，第四个输出是 bar。如果你知道闭包，也很容易解决的： 1234(function(test) &#123; console.log(&quot;inner func: this.foo = &quot; + test.foo); //&apos;bar&apos; console.log(&quot;inner func: self.foo = &quot; + self.foo);&#125;(self)); 如果对闭包不熟悉，可以戳此：从作用域链谈闭包 4、将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。 IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。 12345for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; 上面的输出并不是你以为的0，1，2，3，4，而输出的全部是5，这时 IIFE 就能有用了： 1234567for(var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000); &#125;)(i)&#125; 而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE： 123(function($) &#123; //代码 &#125; )(jQuery); 5、在严格模式(‘use strict’)下进行 JavaScript 开发有神马好处？1234消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 6、下面两个函数的返回值是一样的吗？为什么？1234567891011121314function foo1()&#123; return &#123; bar: &quot;hello&quot; &#125;;&#125;function foo2()&#123; return &#123; bar: &quot;hello&quot; &#125;;&#125; 在编程语言中，基本都是使用分号（;）将语句分隔开，这可以增加代码的可读性和整洁性。而在JS中，如若语句各占独立一行，通常可以省略语句间的分号（;），JS 解析器会根据能否正常编译来决定是否自动填充分号： 123var test = 1 + 2console.log(test); //3 在上述情况下，为了正确解析代码，就不会自动填充分号了，但是对于 return 、break、continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(;)，所以上面的第二个函数就变成了这样： 1234567function foo2()&#123; return; &#123; bar: &quot;hello&quot; &#125;;&#125; 所以第二个函数是返回 undefined。 7、神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param) 来判断一个值是否是 NaN： 123456789console.log(isNaN(NaN)); //trueconsole.log(isNaN(23)); //falseconsole.log(isNaN(&apos;ds&apos;)); //trueconsole.log(isNaN(&apos;32131sdasd&apos;)); //trueconsole.log(NaN === NaN); //falseconsole.log(NaN === undefined); //falseconsole.log(undefined === undefined); //falseconsole.log(typeof NaN); //numberconsole.log(Object.prototype.toString.call(NaN)); //[object Number] ES6 中，isNaN() 成为了 Number 的静态方法：Number.isNaN(). 8、解释一下下面代码的输出12console.log(0.1 + 0.2); //0.30000000000000004console.log(0.1 + 0.2 == 0.3); //false JavaScript 中的 number 类型就是浮点型，JavaScript 中的浮点数采用IEEE-754 格式的规定，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024，每个浮点数占64位。但是，二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字，会有舍入误差。 由于采用二进制，JavaScript 也不能有限表示 1/10、1/2 等这样的分数。在二进制中，1/10(0.1)被表示为 0.00110011001100110011…… 注意 0011 是无限重复的，这是舍入误差造成的，所以对于 0.1 + 0.2 这样的运算，操作数会先被转成二进制，然后再计算： 0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）0.2 =&gt; 0.0011 0011 0011 0011…（无限循环） 双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100…因浮点数小数位的限制而截断的二进制数字，这时候，再把它转换为十进制，就成了 0.30000000000000004。 对于保证浮点数计算的正确性，有两种常见方式。 一是先升幂再降幂： 12345678910function add(num1, num2)&#123; let r1, r2, m; r1 = (&apos;&apos;+num1).split(&apos;.&apos;)[1].length; r2 = (&apos;&apos;+num2).split(&apos;.&apos;)[1].length; m = Math.pow(10,Math.max(r1,r2)); return (num1 * m + num2 * m) / m;&#125;console.log(add(0.1,0.2)); //0.3console.log(add(0.15,0.2256)); //0.3756 二是是使用内置的 toPrecision() 和 toFixed() 方法，注意，方法的返回值字符串。 1234function add(x, y) &#123; return x.toPrecision() + y.toPrecision()&#125;console.log(add(0.1,0.2)); //&quot;0.10.2&quot; 9、实现函数 isInteger(x) 来判断 x 是否是整数可以将 x 转换成10进制，判断和本身是不是相等即可： 1234567891011function isInteger(x) &#123; return parseInt(x, 10) === x; &#125;ES6 对数值进行了扩展，提供了静态方法 isInteger() 来判断参数是否是整数：Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger(&quot;15&quot;) // falseNumber.isInteger(true) // false JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限，并提供了 Number.isSafeInteger() 来判断整数是否是安全型整数。 10、在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？123456(function() &#123; console.log(1); setTimeout(function()&#123;console.log(2)&#125;, 1000); setTimeout(function()&#123;console.log(3)&#125;, 0); console.log(4);&#125;)(); 这个就不多解释了，主要是 JavaScript 的定时机制和时间循环，不要忘了，JavaScript 是单线程的。详解可以参考 从setTimeout谈JavaScript运行机制。 11、写一个少于 80 字符的函数，判断一个字符串是不是回文字符串1234function isPalindrome(str) &#123; str = str.replace(/\\W/g, &apos;&apos;).toLowerCase(); return (str == str.split(&apos;&apos;).reverse().join(&apos;&apos;));&#125; 这个题我在 codewars 上碰到过，并收录了一些不错的解决方式，可以戳这里：Palindrome For Your Dome 12、写一个按照下面方式调用都能正常工作的 sum 方法12345678910111213141516console.log(sum(2,3)); // Outputs 5console.log(sum(2)(3)); // Outputs 5针对这个题，可以判断参数个数来实现：function sum() &#123; var fir = arguments[0]; if(arguments.length === 2) &#123; return arguments[0] + arguments[1] &#125; else &#123; return function(sec) &#123; return fir + sec; &#125; &#125;&#125; 13、根据下面的代码片段回答后面的问题123456for (var i = 0; i &lt; 5; i++) &#123; var btn = document.createElement(&apos;button&apos;); btn.appendChild(document.createTextNode(&apos;Button &apos; + i)); btn.addEventListener(&apos;click&apos;, function()&#123; console.log(i); &#125;); document.body.appendChild(btn);&#125; 1、点击 Button 4，会在控制台输出什么？2、给出一种符合预期的实现方式 1、点击5个按钮中的任意一个，都是输出52、参考 IIFE。 14、下面的代码会输出什么？为什么？123456var arr1 = &quot;john&quot;.split(&apos;&apos;); j o h nvar arr2 = arr1.reverse(); n h o jvar arr3 = &quot;jones&quot;.split(&apos;&apos;); j o n e sarr2.push(arr3);console.log(&quot;array 1: length=&quot; + arr1.length + &quot; last=&quot; + arr1.slice(-1));console.log(&quot;array 2: length=&quot; + arr2.length + &quot; last=&quot; + arr2.slice(-1)); 会输出什么呢？你运行下就知道了，可能会在你的意料之外。 MDN 上对于 reverse() 的描述是酱紫的： Description​ The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array. reverse() 会改变数组本身，并返回原数组的引用。 slice 的用法请参考：slice 15、下面的代码会输出什么？为什么？123456console.log(1 + &quot;2&quot; + &quot;2&quot;);console.log(1 + +&quot;2&quot; + &quot;2&quot;);console.log(1 + -&quot;1&quot; + &quot;2&quot;);console.log(+&quot;1&quot; + &quot;1&quot; + &quot;2&quot;);console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;);console.log( &quot;A&quot; - &quot;B&quot; + 2); 输出什么，自己去运行吧，需要注意三个点： 多个数字和数字字符串混合运算时，跟操作数的位置有关 12console.log(2 + 1 + &apos;3&apos;); / /‘33’console.log(&apos;3&apos; + 2 + 1); //&apos;321&apos; 数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字 12console.log(typeof &apos;3&apos;); // stringconsole.log(typeof +&apos;3&apos;); //number 同样，可以在数字前添加 ”，将数字转为字符串 12console.log(typeof 3); // numberconsole.log(typeof (&apos;&apos;+3)); //string 对于运算结果不能转换成数字的，将返回 NaN 12console.log(&apos;a&apos; * &apos;sd&apos;); //NaNconsole.log(&apos;A&apos; - &apos;B&apos;); // NaN 这张图是运算转换的规则 运算符转换 16、如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码？12345678910var list = readHugeList();var nextListItem = function() &#123; var item = list.pop();if (item) &#123; // process the list item... nextListItem();&#125;&#125;; 原文上的解决方式是加个定时器： 12345678910var list = readHugeList();var nextListItem = function() &#123; var item = list.pop();if (item) &#123; // process the list item... setTimeout( nextListItem, 0);&#125;&#125;; 解决方式的原理请参考第10题。 17、什么是闭包？举例说明可以参考此篇：从作用域链谈闭包 18、下面的代码会输出什么？为啥？123for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );&#125; 请往前面翻，参考第4题，解决方式已经在上面了 19、解释下列代码的输出1234console.log(&quot;0 || 1 = &quot;+(0 || 1));console.log(&quot;1 || 2 = &quot;+(1 || 2));console.log(&quot;0 &amp;&amp; 1 = &quot;+(0 &amp;&amp; 1));console.log(&quot;1 &amp;&amp; 2 = &quot;+(1 &amp;&amp; 2)); 逻辑与和逻辑或运算符会返回一个值，并且二者都是短路运算符： 逻辑与返回第一个是 false 的操作数 或者 最后一个是 true的操作数 123console.log(1 &amp;&amp; 2 &amp;&amp; 0); //0console.log(1 &amp;&amp; 0 &amp;&amp; 1); //0console.log(1 &amp;&amp; 2 &amp;&amp; 3); //3 如果某个操作数为 false，则该操作数之后的操作数都不会被计算 逻辑或返回第一个是 true 的操作数 或者 最后一个是 false的操作数 123console.log(1 || 2 || 0); //1console.log(0 || 2 || 1); //2console.log(0 || 0 || false); //false 如果某个操作数为 true，则该操作数之后的操作数都不会被计算 如果逻辑与和逻辑或作混合运算，则逻辑与的优先级高： 123console.log(1 &amp;&amp; 2 || 0); //2console.log(0 || 2 &amp;&amp; 1); //1console.log(0 &amp;&amp; 2 || 1); //1 在 JavaScript，常见的 false 值： 10, &apos;0&apos;, +0, -0, false, &apos;&apos;,null,undefined,null,NaN 要注意空数组([])和空对象({}): 1234console.log([] == false) //trueconsole.log(&#123;&#125; == false) //falseconsole.log(Boolean([])) //trueconsole.log(Boolean(&#123;&#125;)) //true 所以在 if 中，[] 和 {} 都表现为 true： 20、解释下面代码的输出12console.log(false == &apos;0&apos;)console.log(false === &apos;0&apos;) 请参考前面第14题运算符转换规则的图。 21、解释下面代码的输出12345678var a=&#123;&#125;, b=&#123;key:&apos;b&apos;&#125;, c=&#123;key:&apos;c&apos;&#125;;a[b]=123;a[c]=456;console.log(a[b]); 输出是 456，参考原文的解释： The reason for this is as follows: When setting an object property, JavaScript will implicitly stringify the parameter value. In this case, since b and c are both objects, they will both be converted to “[object Object]”. As a result, a[b] anda[c] are both equivalent to a[“[object Object]”] and can be used interchangeably. Therefore, setting or referencing a[c] is precisely the same as setting or referencing a[b]. 22、解释下面代码的输出1console.log((function f(n)&#123;return ((n &gt; 1) ? n * f(n-1) : n)&#125;)(10)); 结果是10的阶乘。这是一个递归调用，为了简化，我初始化 n=5，则调用链和返回链如下： 递归 123456723、解释下面代码的输出(function(x) &#123; return (function(y) &#123; console.log(x); &#125;)(2)&#125;)(1); 输出1，闭包能够访问外部作用域的变量或参数。 24、解释下面代码的输出，并修复存在的问题1234567891011var hero = &#123; _name: &apos;John Doe&apos;, getSecretIdentity: function ()&#123; return this._name; &#125;&#125;;var stoleSecretIdentity = hero.getSecretIdentity;console.log(stoleSecretIdentity());console.log(hero.getSecretIdentity()); 将 getSecretIdentity 赋给 stoleSecretIdentity，等价于定义了 stoleSecretIdentity 函数： 123var stoleSecretIdentity = function ()&#123; return this._name;&#125; stoleSecretIdentity 的上下文是全局环境，所以第一个输出 undefined。若要输出 John Doe，则要通过 call 、apply 和 bind 等方式改变 stoleSecretIdentity 的this 指向(hero)。 第二个是调用对象的方法，输出 John Doe。 25、给你一个 DOM 元素，创建一个能访问该元素所有子元素的函数，并且要将每个子元素传递给指定的回调函数。函数接受两个参数： DOM​ 指定的回调函数 原文利用 深度优先搜索(Depth-First-Search) 给了一个实现： 1234567function Traverse(p_element,p_callback) &#123; p_callback(p_element); var list = p_element.children; for (var i = 0; i &lt; list.length; i++) &#123; Traverse(list[i],p_callback); // recursive call &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"ZYLZYL.github.io/tags/前端/"},{"name":"javascript面试中的题目","slug":"javascript面试中的题目","permalink":"ZYLZYL.github.io/tags/javascript面试中的题目/"}]},{"title":"ES6中新特性","date":"2017-02-27T14:30:41.000Z","path":"2017/02/27/ES6中新特性/","text":"ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 ES6新增添很多功能。更加方便我们的使用功能，话不多少。进入主题。 一、关于变量ES51.只有全局作用域变量和函数作用域变量2.“变量提升”（当程序进入一个新的函数时，会将该函数中所有的变量的声明放在函数开始的位置。仅仅会提升变量的声明，不会提升变量的赋值） ES6新增：块级作用域变量1、let定义块级作用域变量12345678910111213141、没有变量的提升，必须先声明后使用2、let声明的变量，不能与前面的let，var，conset声明的变量重名 &#123; &#123; //console.log(a)//报错 必须先声明再使用 let a = 10;//只在当前大括号可以使用 var b = &quot;abc&quot;;//全局作用域变量 console.log(a);//10 //let a = 10//报错 Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared console.log(b);//bac &#125; console.log(b);//abc // console.log(a);//报错 只能在大括号中使用 &#125; 2、const 定义只读变量 1、const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改2、const声明变量也是一个块级作用域变量3、const声明的变量没有“变量的提升”，必须先声明后使用4、const声明的变量不能与前面的let， var ， const声明的变量重名 12345&#123; const VERSION = &quot;1.2.3&quot; console.log( VERSION )//也只能在括号里使用 &#125; //console.log( VERSION )//VERSION is not defined 报错 也是只读变量 二、关于函数ES6可以给形参函数设置默认值就是说，当我们调用函数时，如果设置了默认形参，即使没给函数传入实参，那么函数的实参就是默认形参。1234567891011121314151617function fun2(a=1,b=2)&#123; console.log(a,b)//1,2&#125;fun2(11,22);//11 22fun2(100);//100 2在构造函数中也可是使用的 function Person(name,age,sex=&quot;男&quot;)&#123; this.name = name; this.age = age; this.sex = sex;&#125;var p1 = new Person(&quot;张三&quot;,20);console.log(p1)// Person &#123;name: &quot;张三&quot;, age: 20, sex: &quot;男&quot;&#125;var p2 = new Person(&quot;赵四&quot;,30);console.log(p2)// Person &#123;name: &quot;赵四&quot;, age: 30, sex: &quot;男&quot;&#125;var p3 = new Person(&quot;翠花&quot;,20,&quot;女&quot;);console.log(p3)// Person &#123;name: &quot;翠花&quot;, age: 20, sex: &quot;女&quot; 箭头函数1234567//正常函数var fun3 = function(a)&#123; console.log(a);&#125;//箭头函数var fun3 = (a)=&gt;&#123;console.log(a);&#125;fun3(999); 比如我们用箭头函数计算一个1到100的和1234567891011121314151617 var fun4 = ()=&gt;&#123; var sum=0; for(var i = 0; i&lt;=100; i++)&#123; sum = sum+i &#125; return sum; &#125; console.log(fun4());//1000 var person = &#123; name:&quot;tom&quot;, sayHi:()=&gt;&#123; console.log(this);//window对象 console.log(&quot;hello,everyone. my name is &quot;+this.name);//hello,everyone. my name is window的name &#125; &#125; person.sayHi();同时复习一下this的认识 1.在函数体外，this指的就是window对象2.在函数替内，谁调用函数this就指向谁3.在构造函数中，this指的是新创建的对象4.在html标签中，this指的是当前的这个标签元素5.在ES6中，对于箭头函数，要看它在哪里创建的，和当前函数的作用域。 三、关于数组的展开运算在数组之前加上三个点（…）123456789101112var arr = [1,2,3,4,5]; console.log(arr);//[1, 2, 3, 4, 5] console.log(...arr)// 1 2 3 4 5 可以根据数组的展开运算用数组给函数批量的传参 function fun5(a,b,c,d,e,f)&#123; //如果没有展开数组，打印结果如下 //console.log(a,b,c,d,e,f)//[1, 2, 3, 4, 5] undefined undefined undefined undefined undefine console.log(a,b,c,d,e,f)//11 22 33 44 55 66 //return a+b+c+d+e+f &#125; //fun5([1,2,3,4,5]) fun5(...[11,22,33,44,55,66]) 四、关于apply和callapply和call，都是对象本身没有某个属性或者方法，去引用其他对象的属性或方法，也就是说两者都可以改变this的属性不同之处 apply(this的指向，数组/arguments)call(this的指向，参数1，参数2，参数3) 12345678910111213141516171819202122232425var name =&quot;window的name&quot;;var obj = &#123; name:&quot;obj的name&quot;, showName:function(v1,v2,v3)&#123; console.log(v1,v2,v3)&#125;&#125;obj.showName();obj.showName.apply(window,[10,20,30]);//10 20 30//apply括号里的是谁，调用的前面的函数里面的this就是谁obj.showName.call(window,10,20,30)//10 20 30var color = &quot;yellow&quot;;function showColor()&#123; console.log(this.color)&#125;var obj = &#123; color:&quot;red&quot;,&#125;showColor();//yellowshowColor.apply(obj);//redshowColor.call(obj);//redshowColor.apply(this);//yellowshowColor.call(window);//yellow 五、关于解构赋值数组的解构赋值 12345var [a,b,c]=[11,22,33]console.log(a,b,c)//11 22 33var [e,[f,g],k] = [1,[2,3],5]console.log(e,f,g,k)//1 2 3 5 对象的解构赋值 12var&#123;name,age&#125;=&#123;name:&quot;张三&quot;,age:&quot;20&quot;&#125;console.log(name,age)//张三 20 以前我们互换两个变量的值，需要借助第三个变量，利用解构赋值，就方便很多了 1234var f1 = 88;var f2 = 99;[f1,f2]=[f2,f1];console.log(f1,f2)//99 88 解构json 12345678910111213var jike = &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:&quot;23&quot;,&quot;sex&quot;:&quot;男&quot;&#125;;var &#123;name,age,sex&#125;=jike;console.log(name,age,sex)//tom 23 男function cal(a,b)&#123; var ret1 = a+b; var ret2 = a-b; var ret3 = a*b; var ret4 = a/b; return [ret1,ret2,ret3,ret4]&#125;var [r1,r2,r3,r4] = cal(10,5);console.log(r1,r2,r3,r4)//15 5 50 2 六、string中加入include方法includes(“字符”); 用于判断字符串中是否包含某个字符存在返回true 不存在返回false includes(“字符”,startIndex); 用于判断字符串中下标startIndex是否是某个字符是返回true 不是返回false 123var str = &quot;hello&quot;;console.log( str.includes(&quot;e&quot;) )//trueconsole.log( str.includes(&quot;e&quot;,3) );//false 七、创建对象ES5中创建对象的几种方法1.字面量法2.工厂模式3.构造函数4.组合方式 构造函数+原型模式 ES6中创建对象 class 类名{​ //肯定存在一个构造函数​ //如果不写构造函数，有一个默认的构造函数,内容为空​ constructor(){} //注意：这里不需要逗号​ //下面是函数属性 比如属性有run dark​ run(){}​ dark(){}} 举个例子 12345678910111213141516class Person&#123; //肯定存在一个构造函数 constructor(name,age,sex,nativePlace)&#123; this.name=name;//注意：这里是分号 this.age=age; this.sex=sex; this.nativePlace=nativePlace; &#125; //下面是函数属性 eat()&#123;console.log(&quot;红烧排骨&quot;)&#125; study()&#123;console.log(&quot;英文&quot;)&#125; play()&#123;console.log(&quot;敲代码&quot;)&#125;&#125;var sunShine = new Person(&quot;fanfan&quot;,&quot;22&quot;,&quot;女&quot;,&quot;黑龙江&quot;);console.log(sunShine)//Person &#123;name: &quot;fanfan&quot;, age: &quot;22&quot;, sex: &quot;女&quot;, nativePlace: &quot;黑龙江&quot;&#125; 八、继承1234567891011121314151617181920212223242526272829303132class Animal&#123; constructor(age,sex)&#123; this.age = age; this.sex = sex; &#125; eat()&#123; console.log(&quot;吃吃吃&quot;) &#125;&#125;class Dog extends Animal&#123; constructor(name,age,sex)&#123; //super指的是父类，先调用父类的构造函数，然后再去添加属性 super(age,sex) //console.log(super);//不能打印只能使用 this.name=name; &#125; bark()&#123; console.log(&quot;哇哇哇&quot;) &#125; //重写：在子类中重新定义父类中的方法 // eat()&#123; // console.log(&quot;喝喝喝&quot;) // &#125;&#125;var d = new Dog(&quot;妞妞&quot;,&quot;男&quot;,5)console.log(d)d.bark();d.eat();//ES6的继承，有两条继承链，构造函数 和 原型函数条 console.log( Dog.prototype)//Animal &#123;&#125;console.log( Dog.constructor==Animal.constructor)//trueconsole.log( Dog.prototype.__proto__==Animal.prototype)//true 九、Set（）和Map（）set（）有序列表集合（没有重复）Set()是指有序列表集合 (set中的元素是没有重复的) set包含的方法add()、has()、delete()、clear()等 add（）添加 1234567891011121314var s = new Set();s.add(1);s.add(window);s.add(true);s.add(1);console.log(s);//一共三个元素console.log(s.size)//数组的长度是3delete（value） 删除指定元素//结合上栗s.delete(window);console.log(s) //1 trueconsole.log(s.size) //2 has( value )用来判断指定的值是否在set集合中存在返回true 不存在返回false //结合上栗console.log( s.has(1) )//true clear（） 同来清空set集合的 //结合上栗s.clear()console.log(s)//此时为空 举个例子：生成10个1-20的随机数，要求不可以重复 1234567var arr3 = new Set(); while(arr3.size&lt;10)&#123; var yuan = parseInt(Math.random() * (20 - 1 + 1) + 1); arr3.add(yuan); &#125; console.log(arr3) Map() 用来存放键值对的集合 key/value 12345678var map = new Map();map.set(&quot;name&quot;,&quot;张三&quot;);map.set(&quot;age&quot;,20);console.log(map) //Map &#123;&quot;name&quot; =&gt; &quot;张三&quot;, &quot;age&quot; =&gt; 20&#125;get(key)根据key值取得valueconsole.log( map.get(&quot;name&quot;))//张三 has() 判断是否存在某个键值对存在返回true 不存在返回fasle 1234567console.log( map.has(&quot;age&quot;) ) //true console.log( map.has(&quot;age1&quot;) ) //falseclear() 清空集合map.clear();console.log(map);//Map &#123;&#125;","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"ZYLZYL.github.io/tags/ES6/"},{"name":"新特性","slug":"新特性","permalink":"ZYLZYL.github.io/tags/新特性/"}]},{"title":"javascript常用的算法问题","date":"2017-02-26T14:08:55.000Z","path":"2017/02/26/javascript常用的算法问题/","text":"前端面试中的常见的算法问题文章目录 Q1 判断一个单词是否是回文？ Q2 去掉一组整型数组重复的值 Q3 统计一个字符串出现最多的字母 Q4 排序算法 Q5 不借助临时变量，进行两个整数的交换 Q6 使用canvas 绘制一个有限度的斐波那契数列的曲线？ Q7 找出下列正数组的最大差值比如: Q8 随机生成指定长度的字符串 Q9 实现类似getElementsByClassName 的功能 Q10 使用JS 实现二叉查找树(Binary Search Tree) 扩展阅读 虽说我们很多时候前端很少有机会接触到算法。大多都交互性的操作，然而从各大公司面试来看，算法依旧是考察的一方面。实际上学习数据结构与算法对于工程师去理解和分析问题都是有帮助的。如果将来当我们面对较为复杂的问题，这些基础知识的积累可以帮助我们更好的优化解决思路。下面罗列在前端面试中经常撞见的几个问题吧。 Q1 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider . 很多人拿到这样的题目非常容易想到用for 将字符串颠倒字母顺序然后匹配就行了。其实重要的考察的就是对于reverse的实现。其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。 12345function checkPalindrom(str) &#123; return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125; Q2 去掉一组整型数组重复的值 比如输入: [1,13,24,11,11,14,1,2] 输出: [1,13,24,11,14,2] 需要去掉重复的11 和 1 这两个元素。 这道问题出现在诸多的前端面试题中，主要考察个人对Object的使用，利用key来进行筛选。 12345678910111213141516171819202122let unique = function(arr) &#123;let hashTable = &#123;&#125;;let data = [];for(let i=0,l=arr.length;i&lt;l;i++) &#123;if(!hashTable[arr[i]]) &#123;hashTable[arr[i]] = true;data.push(arr[i]);&#125;&#125;return data&#125;module.exports = unique; Q3 统计一个字符串出现最多的字母给出一段英文连续的英文字符窜，找出重复出现次数最多的字母 输入 ： afjghdfraaaasdenas 输出 ： a 前面出现过去重的算法，这里需要是统计重复次数。 1234567891011121314151617181920212223242526272829303132333435363738function findMaxDuplicateChar(str) &#123;if(str.length == 1) &#123;return str;&#125;let charObj = &#123;&#125;;for(let i=0;i&lt;str.length;i++) &#123;if(!charObj[str.charAt(i)]) &#123; charObj[str.charAt(i)] = 1;&#125;else&#123; charObj[str.charAt(i)] += 1;&#125;&#125;let maxChar = &apos;&apos;, maxValue = 1;for(var k in charObj) &#123;if(charObj[k] &gt;= maxValue) &#123; maxChar = k; maxValue = charObj[k];&#125;&#125;return maxChar;&#125;module.exports = findMaxDuplicateChar; Q4 排序算法如果抽到算法题目的话，应该大多都是比较开放的题目，不限定算法的实现，但是一定要求掌握其中的几种，所以冒泡排序，这种较为基础并且便于理解记忆的算法一定需要熟记于心。冒泡排序算法就是依次比较大小，小的的大的进行位置上的交换。 12345678910111213141516function bubbleSort(arr) &#123; for(let i = 0,l=arr.length;i&lt;l-1;i++) &#123; for(let j = i+1;j&lt;l;j++) &#123; if(arr[i]&gt;arr[j]) &#123; let tem = arr[i]; arr[i] = arr[j]; arr[j] = tem; &#125; &#125; &#125; return arr;&#125;module.exports = bubbleSort; 除了冒泡排序外，其实还有很多诸如 插入排序,快速排序，希尔排序等。每一种排序算法都有各自的特点。全部掌握也不需要，但是心底一定要熟悉几种算法。 比如快速排序，其效率很高，而其基本原理如图(来自wiki)： 算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了。 12345678910111213141516171819202122function quickSort(arr) &#123;if(arr.length&lt;=1) &#123; return arr;&#125;let leftArr = [];let rightArr = [];let q = arr[0];for(let i = 1,l=arr.length; i&lt;l; i++) &#123; if(arr[i]&gt;q) &#123; rightArr.push(arr[i]); &#125;else&#123; leftArr.push(arr[i]); &#125;&#125;return [].concat(quickSort(leftArr),[q],quickSort(rightArr));&#125;module.exports = quickSort; 安利大家一个学习的地址，通过动画演示算法的实现。 HTML5 Canvas Demo: Sorting Algorithms Q5 不借助临时变量，进行两个整数的交换输入 a = 2, b = 4 输出 a = 4, b =2 这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b进行置换。 主要是利用 + - 去进行运算，类似 a = a + ( b - a) 实际上等同于最后 的 a = b; 12345678910111213function swap(a , b) &#123; b = b - a; a = a + b; b = a - b; return [a,b];&#125;module.exports = swap; Q6 使用Canvas 绘制一个有限度的斐波那契数列的曲线？ 数列长度限定在9. 斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列主要考察递归的调用。我们一般都知道定义 fibo[i] = fibo[i-1]+fibo[i-2]; 生成斐波那契数组的方法 1234567891011121314151617181920function getFibonacci(n) &#123;var fibarr = [];var i = 0;while(i&lt;n) &#123;if(i&lt;=1) &#123; fibarr.push(i);&#125;else&#123; fibarr.push(fibarr[i-1] + fibarr[i-2])&#125;i++;&#125;return fibarr;&#125; 剩余的工作就是利用canvas arc方法进行曲线绘制了 DEMO Q7 找出下列正数组的最大差值比如:输入 [10,5,11,7,8,9] 输出 6 这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。 function getMaxProfit(arr) {var minPrice = arr[0];var maxProfit = 0;for (var i = 0; i &lt; arr.length; i++) { var currentPrice = arr[i]; minPrice = Math.min(minPrice, currentPrice); var potentialProfit = currentPrice - minPrice; maxProfit = Math.max(maxProfit, potentialProfit);}return maxProfit;} Q8 随机生成指定长度的字符串实现一个算法，随机生成指制定长度的字符窜。 比如给定 长度 8 输出 4ldkfg9j 1234567891011121314151617181920function randomString(n) &#123;let str = &apos;abcdefghijklmnopqrstuvwxyz9876543210&apos;;let tmp = &apos;&apos;, i = 0, l = str.length;for (i = 0; i &lt; n; i++) &#123;tmp += str.charAt(Math.floor(Math.random() * l));&#125;return tmp;&#125;module.exports = randomString; Q9 实现类似getElementsByClassName 的功能自己实现一个函数，查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName querySelectorAll 等原生提供DOM查找函数。 1234567891011121314151617181920212223242526function queryClassName(node, name) &#123; var starts = &apos;(^|[ \\n\\r\\t\\f])&apos;, ends = &apos;([ \\n\\r\\t\\f]|$)&apos;;var array = [], regex = new RegExp(starts + name + ends), elements = node.getElementsByTagName(&quot;*&quot;), length = elements.length, i = 0, element;while (i &lt; length) &#123; element = elements[i]; if (regex.test(element.className)) &#123; array.push(element); &#125; i += 1;&#125;return array;&#125; Q10 使用JS 实现二叉查找树(Binary Search Tree)一般叫全部写完的概率比较少，但是重点考察你对它的理解和一些基本特点的实现。 二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树： 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。 在写的时候需要足够理解二叉搜素树的特点，需要先设定好每个节点的数据结构 1234567891011class Node &#123;constructor(data, left, right) &#123; this.data = data; this.left = left; this.right = right;&#125;&#125; 树是有节点构成，由根节点逐渐延生到各个子节点，因此它具备基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class BinarySearchTree &#123;constructor() &#123; this.root = null;&#125;insert(data) &#123;let n = new Node(data, null, null);if (!this.root) &#123; return this.root = n;&#125;let currentNode = this.root;let parent = null;while (1) &#123; parent = currentNode; if (data &lt; currentNode.data) &#123; currentNode = currentNode.left; if (currentNode === null) &#123; parent.left = n; break; &#125; &#125; else &#123; currentNode = currentNode.right; if (currentNode === null) &#123; parent.right = n; break; &#125; &#125;&#125;&#125;remove(data) &#123; this.root = this.removeNode(this.root, data)&#125;removeNode(node, data) &#123;if (node == null) &#123; return null;&#125;if (data == node.data) &#123; // no children node if (node.left == null &amp;&amp; node.right == null) &#123; return null; &#125; if (node.left == null) &#123; return node.right; &#125; if (node.right == null) &#123; return node.left; &#125; let getSmallest = function(node) &#123; if(node.left === null &amp;&amp; node.right == null) &#123; return node; &#125; if(node.left != null) &#123; return node.left; &#125; if(node.right !== null) &#123; return getSmallest(node.right); &#125; &#125; let temNode = getSmallest(node.right); node.data = temNode.data; node.right = this.removeNode(temNode.right,temNode.data); return node;&#125; else if (data &lt; node.data) &#123; node.left = this.removeNode(node.left,data); return node;&#125; else &#123; node.right = this.removeNode(node.right,data); return node;&#125;&#125;find(data) &#123;var current = this.root;while (current != null) &#123; if (data == current.data) &#123; break; &#125; if (data &lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right &#125;&#125;return current.data;&#125;&#125;module.exports = BinarySearchTree; 文章来源：http://caibaojian.com/toutiao/6970扩展阅读https://www.interviewcake.com/question/javascript/rectangular-love http://stackoverflow.com/questions/21853967/get-elements-by-class-a-or-b-in-javascript http://codepen.io/Jack_Pu/pen/EgrXBp http://javascript-html5-tutorial.com/algorithms-and-data-structures-in-javascript.html 原文：http://www.jackpu.com/qian-duan-mian-shi-zhong-de-chang-jian-de-suan-fa-wen-ti/ 相关文章 2016阿里前端开发实习生面试经历 659Views 前端开发面试题及答案 1,436Views 一个前端的自我修养 993Views 谈谈前端开发与自学 1,684Views 前端开发面试题及答案整理 743Views 写好技术简历的47条原则 610Views 前端程序员:月薪5K到5万,我干了啥 1,417Views 排序算法总结 292Views 前端面试题整理 3,298Views 前端程序员谈高薪技巧 1,253Views","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"算法","slug":"算法","permalink":"ZYLZYL.github.io/tags/算法/"}]},{"title":"javascript的运行机制","date":"2017-02-25T14:44:00.000Z","path":"2017/02/25/javascript的运行机制/","text":"JavaScript的运行机制 前言： 本文是写作在给团队新人培训之际，所以其实本文的受众是对JavaScript的运行机制不了解或了解起来有困难的小伙伴。也就是说，其实真正的原理和本文阐述的并不完全符合，就如中学课本和大学课本一样，大学老师会告诉你高中的一些东西是在某些理想情况下得到的结论，本文同理。 本文的目的是希望大家阅读之后能对JavaScript的运行机制有一个比较直观比较快的认识，但更重要的是自己动手实践，只有实践才能真正发现问题和得到提升:) 收到了大家的支持和反馈，非常感谢。 想要理解JavaScript的运行机制，需要分别深刻理解以下几个点： JavaScript的单线程机制 任务队列（同步任务和异步任务） 事件和回调函数 定时器 Event Loop（事件循环） JavaScript的单线程机制JavaScript的一个语言特性（也是这门语言的核心）就是单线程。什么是单线程呢？简单地说就是同一时间只能做一件事，当有多个任务时，只能按照一个顺序一个完成了再执行下一个。 JavaScript的单线程与它的语言用途是有关的。作为一门浏览器脚本语言，JavaScript的主要用途是完成用户交互、操作DOM。这就决定了它只能是单线程，否则会导致复杂的同步问题。 设想JavaScript同时有两个线程，一个线程需要在某个DOM节点上添加内容，而另一个线程的操作是删除了这个节点，那么浏览器应该以谁为准呢？ 所以为了避免复杂性，JavaScript从诞生起就是单线程。 为了提高CPU的利用率，HTML5提出web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以这个标准并没有改变JavaScript单线程的本质。 任务队列一个接一个地完成任务也就意味着待完成的任务是需要排队的，那么为什么会需要排队呢？ 通常排队有以下两种原因： 任务计算量过大，CPU处于忙碌状态； 任务所需的东西为准备好所以无法继续执行，导致CPU闲置，等待输入输出设备（I/O设备）。&gt; 比如有的任务你需要ajax获取到数据才能往下执行 由此JavaScript的设计者也意识到，这时完全可以先运行后面已经就绪的任务来提高运行效率，也就是把等待中的任务先挂起放到一边，等得到需要的东西再执行。就好比接电话时对方离开了一下，这时正好有另一个来电，于是你便把当前通话挂起，等那个通话结束后，再连回之前的通话。 所以也就出现了同步和异步的概念，任务也被分成了两种，一种是同步任务（Synchronous），另一种是异步任务（Asynchronous）。 同步任务：需要执行的任务在主线程上排队，一个接一个，前一个完成了再执行下一个 异步任务：没有马上被执行但需要执行的任务，存放在“任务队列”（task queue）中，“任务队列”会通知主线程什么时候哪个异步任务可以执行，然后这个任务就会进入主线程并被执行。&gt; 所有的同步执行都可以看作是没有异步任务的异步执行 具体来说，异步执行如下： 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。也就是所有能被马上执行的任务都在主线程上排好了队，一个接一个的被执行。 主线程之外，还存在一个“任务队列”（task queue）。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。 ​ 也就是说每个异步任务准备好了就会立一个唯一的flag，这个flag用来标识对应的异步任务。 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，就结束等待装袋，进入执行栈开始被执行。 ​ 也就是主线程把之前的任务做完了之后，就会来看“任务队列”中的flag，来把对应的异步任务打包来执行。 主线程不断重复以上三步。 ​ 只要主线程空了，就会去读取“任务队列”。这个过程会被不断重复，这就是JavaScript的运行机制。 事件和回调函数事件“任务队列”是一个事件的队列（也可以理解成是消息的队列），IO设备完成一项任务，就会在“任务队列”中添加一个时间，表示相关的异步任务可以进入“执行栈”。接着主线程读取“任务队列”，查看里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入“任务队列”，等待主线程读取。 回调函数所谓“回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，“任务队列”上第一位的事件就自动进入主线程。但是，如果包含“定时器”，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 Event Loop主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的运行机制又称为“Event Loop”（事件循环） 为了更好地理解Event Loop，下面参照Philip Roberts的演讲中的一张图。 上图中，主线程在运行时，产生了heap（堆）和stack（栈），栈中的代码调用各种外部API，并在“任务队列”中加入各种事件（click，load，done）。当栈中的代码执行完毕，主线程就会读取“任务队列”，并依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取“任务队列”（异步任务）之前执行。 12345var req = new XMLHttpRequest();req.open(&apos;GET&apos;, url);req.onload = function ()&#123;&#125;;req.onerror = function ()&#123;&#125;;req.send(); 上面的代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取“任务队列”。所以，它与以下的写法是等价的。 12345var req = new XMLHttpRequest();req.open(&apos;GET&apos;, url);req.send();req.onload = function ()&#123;&#125;;req.onerror = function ()&#123;&#125;; 也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面是无关紧要的，因为它们属于执行栈的一部分，系统总是执行完它们才会去读取“任务队列”。 定时器除了放置异步任务的事件，“任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做定时器（timer）功能，也就是定时执行的代码。 SetTimeout()和setInterval()可以用来注册在指定时间之后单次或重复调用的函数，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者会在指定毫秒数的间隔里重复调用: 1setInterval(updateClock, 60000); //60秒调用一次updateClock() 因为它们都是客户端JavaScript中重要的全局函数，所以定义为Window对象的方法。 但作为通用函数，其实不会对窗口做什么事情。 Window对象的setTImeout()方法用来实现一个函数在指定的毫秒数之后运行。所以它接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。 setTimeout()和setInterval()返回一个值，这个值可以传递给clearTimeout()用于取消这个函数的执行。 123console.log(1);setTimeout(function()&#123;console.log(2);&#125;, 1000);console.log(3); 上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。 如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。 12setTimeout(function()&#123;console.log(1);&#125;, 0);console.log(2) 上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会执行“任务队列”中的回调函数。 总之，setTimeout(fn,o)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是尽可能早地执行。它在“任务队列”的尾部添加一个事件，因此要等到同步任务和“任务队列”现有的事件都处理完，才会的到执行。 HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。 需要注意的是，setTimeout()只是将事件插入了“任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证回调函数一定会在setTimeout()指定的时间执行。 由于历史原因，setTimeout()和setInterval()的第一个参数可以作为字符串传入。如果这么做，那这个字符串会在指定的超时时间或间隔之后进行求值（相当于执行eval()）。 关于深入理解定时器的工作原理，这里推荐阅读jQuery的作者John Resig的一篇文章： http://ejohn.org/blog/how-javascript-timers-work/ 我自己也翻译了这篇文章，如有问题，欢迎指正：http://guoxunique.com/2016/12/07/how-javascript-timers-work/ 参考阮一峰老师的博文 http://www.ruanyifeng.com/blog/2014/10/event-loop.html 参考《JavaScript权威指南》 来自：http://guoxunique.com/2016/12/04/javascript-operating-mechanism/","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"ZYLZYL.github.io/tags/前端/"},{"name":"jsvascript","slug":"jsvascript","permalink":"ZYLZYL.github.io/tags/jsvascript/"},{"name":"运行机制","slug":"运行机制","permalink":"ZYLZYL.github.io/tags/运行机制/"}]},{"title":"JavaScript中sort()排序方法使用","date":"2017-02-24T07:08:53.000Z","path":"2017/02/24/JavaScript中sort-排序方法使用/","text":"JavaScript中sort()排序方法使用 定义 sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照ASC码进行排序，这个大家都能理解，但如果数组元素是一个Object呢，转不了字符串，难道不能进行排序？答案当然是否定的,那么我们就来详细探讨下sort()方法的使用 语法：arrayObject.sort(sortby)；参数sortby可选。规定排序顺序。必须是函数。 sort() 方法用于对数组的元素进行排序。 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点， 首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。 比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 用js中的sort()方法排序数字 var arr=[23,12,1,34,116,8,18,37,56,50]; alert(arr.sort(); 返回：[1, 116, 12, 18, 23, 34, 37, 50, 56, 8] 上面的代码没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数： var arr = [23,12,1,34,116,8,18,37,56,50]; functionsequence(a,b){ if(a&gt;b) { return 1; }elseif(a return -1 }else{ return 0; } } onsole.log(arr.sort(sequence)); 返回：[1, 8, 12, 18, 23, 34, 37, 50, 56, 116] (没有问题) 当然也可以把排序函数写到sort()方法里面： var arr = [23,12,1,34,116,8,18,37,56,50]; vararr2 = arr.sort(function(a,b){ if(a&gt;b) { return1; }elseif(a return -1 }else{ return 0; } }) console.log(arr2); 返回：[1, 8, 12, 18, 23, 34, 37, 50, 56, 116] (也没有问题) 也可以简化成这样的写法因为：若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值 ` var arr = [23,12,1,34,116,8,18,37,56,50];` ` function sequence(a,b){` `return a - b;` ​ ` }` ` console.log(arr.sort(sequence));` 返回：[1, 8, 12, 18, 23, 34, 37, 50, 56, 116] (也是正确的) 关系字母顺序进行排序 就简单多了，直接用sort()方法就OK了： ` var arr = ['fanda','banner','find','zoom','index','width','javascript'];` ` console.log(arr.sort());` 返回：[“banner”, “fanda”, “find”, “index”, “javascript”, “width”, “zoom”] 现在在学习javascript中，发现sort()函数是有点奇怪的东西（可能是本人水平的问题-_-！），于是就在这里记录一下自己找到的东西吧。sort()这个方法的参数很奇怪，必须是函数，但也是可选参数，如果没有参数的话，就会默认以字符串的字典顺序来排列（就算是数值，也会被转化为字符串来处理）。这个参数是要能够比较两个值的大小，如： function sortNumber(a, b){ return a - b; //这里返回的是他们的差值，如果是小于0的值，就会将a排在前面，如果大于0,就会将b排在前面,如果是0的话，就随便。（冒泡排序法！！） } 应用如下（这个例子太经典了！！）： `function sortNumber(a,b){return a - b}` `var arr = new Array(3)` `arr[0] = \"10\";` `arr[1] = \"5\";` `arr[2] = \"4\";` `document.write(arr + \"\");` `document.write(arr.sort(sortNumber));` 那么原本是10,5,4的排列就会变成4,5,10.这里说明一下这个过程，明明sortNumber应该是有两个参数，但是我们在调用时却一个参数都没有，怎么进行比较啊？这里是这样的，当arr从第一个数开始调用sort时，10前面是没有数与它比较的，所以就到第二个，就是5，这时10就会与5比较，于是就会调用sortNumber并将10和5传进去，这是sort（）的特性。 qq:1074316837 邮箱：desedematong@gmail.com","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"ZYLZYL.github.io/tags/javascript/"},{"name":"前端，sort()排序","slug":"前端，sort-排序","permalink":"ZYLZYL.github.io/tags/前端，sort-排序/"}]},{"title":"asp各种错误提示代码含义","date":"2017-02-23T01:42:41.000Z","path":"2017/02/23/asp中各种错误提示码含义/","text":"asp中各种错误代码集合 ASP是非常简单的，以至于许多的开发者不会去思考错误处理。错误处理能够让你的应用程序更加合理。我看到过很多个用ASP编写的商业网站，大多数都忽略了错误处理。 错误的类型有三种主要的错误类型：１．编译错误： 这种错误出现一般都是代码的语法问题。因为编译错误而导致辞ASP停止运行。２．运行错误： 这个错误是发生在你准备运行ASP时的。例如：如果你试图给一个变量赋值，但是却超出了该变量允许的范围。３．逻辑错误： 逻辑错误是最难被发现的，这种错误经常是一种结构错误，电脑是发现不了的。这就需要我们彻头彻尾地检查我们的代码。 因为编译错误一般是和逻辑错误一起发生的，一般都能显示出来，所以我们担心的就只是运行错误。它都终止ASP的运行，而且给用户丢下一堆很不友好的文字。 那么我们要怎样处理运行错误呢？ 错误类型：ADODB.Field (0x800A0BCD)BOF 或 EOF 中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。原因：你在利用SQL查找数据库的记录时，查找结果为空，而且你没有对空记录的情况做出处理。解决：1 如果你不相信查找结果为空，那你应该考虑你的SQL语句是否正确；2 如果确实有空的情况，那你应该添加”if rs.eof then”或者”do while not rs.eof”之类的语句，对eof的情况进行处理。 错误类型：(0x80020009)发生意外。原因：也是在利用SQL查找数据库记录时，查找结果为空，而且你在后面的代码中调用了rs(“aa”)之类的记录解决：要么同上，加上rs.eof的判断和处理，要么就是你的SQL语句有误，导致记录查不出来，也就无法在后来使用rs(“aa”)的记录了。 错误类型：Active Server Pages, ASP 0126 (0x80004005)找不到包含文件 ‘xxx.asp’。原因：就如错误提示所说，不存在这个包含文件。解决：如果你确定有这个文件，那么就是你的路径写错了，比如说其实他相对于网站根目录的路径应该是inc/xxx.asp，那么include里面就应该写inc/xxx.asp，而不仅仅是xxx.asp。附：include的写法是： 错误类型：Microsoft OLE DB Provider for ODBC Drivers (0x80004005)[Microsoft][ODBC Microsoft Access Driver] 操作必须使用一个可更新的查询。原因：这个在XP服务器上非常常见，属于服务器的配置问题，或者说是用户的权限问题。解决：如果仅仅是在本机上调试出现的错误，则右键点击网站所在的文件夹，点击”共享和安全…”，在”安全”中点添加…，写入everyone,然后再使这个用户的权限为所有，即除了第一个外全部打勾，确定之后再刷新就可以用了。(注：如果找不到“安全”选项，则在任意一个文件夹下点击“工具”，然后是“文件夹选项”－－“查看”，在“使用简单文件共享”一栏把勾去掉即可) 错误类型：Microsoft VBScript 编译器错误 (0x800A0401)语句未结束原因：语法错误。解决：按系统所提示的行来检查。如果提示的恰好是本页的最后一行，则很有可能是if语句忘记写”end if”啦，select语句忘记写”end select”啦，总之是需要end的地方没有end，导致服务器找不到语句的结尾，只好在最后一行显示错误。 错误类型：Microsoft JET Database Engine (0x80040E10)至少一个参数没有被指定值。原因：在写SQL语句的时候，我们经常会调用一些参数，很可能这些参数中有一个没有被赋值。解决：检查每一个参数的值是否真的传递过来了，很可能有些参数其实是””，这样的参数去索引数据库当然是不行的。 错误类型：Microsoft JET Database Engine (0x80040E37)Microsoft Jet 数据库引擎找不到输入表或查询 ‘AA’。 确定它是否存在，以及它的名称的拼写是否正确。原因：不存在这个表。解决：应该是你写错了表名，或者连错了数据库？再仔细核对一下吧！ 错误类型：Microsoft VBScript 运行时错误 (0x800A000D)类型不匹配: \\’[string: “”]\\’’原因：是因为你的变量的类型是字符串型的，而你却当作数字或者其他类型来使用。解决：比如你需要数字的变量用来计算i=i+1等数学运算，那么应该在变量上使用cint(变量名)，强制转换为数字型，两个变量之间作比较也一定要是相同的类型，因此也需要转换，方法同上。 错误类型：Microsoft JET Database Engine (0x80040E07)标准表达式中数据类型不匹配。原因：一般也是在写SQL语句时发生了错误，即把数字型和字符串型的变量混淆了。解决：很好办，试一试把SQL中变量加了’’的去掉单引号，或者把原先认为是数字的加上’’，再查看效果。 错误类型：Microsoft VBScript 运行是错误（0x800A01A8）缺少对象：”原因：很有可能是你没有对rs对象进行定义。解决：别忘了写set rs=server.CreateObject(“adodb.recordset”)，这样可以定义对象；或者直接不用这种写法，直接用conn.execute(“SQL”)这样会方便得多，也不用考虑对象问题。 错误类型：Microsoft VBScript 运行时错误 (0x800A005E)无效使用 Null: ‘Replace’原因：无效使用函数的情况也比较多见，包括Split等，这个道理也比较简单，就是因为你Replace的内容是空的。解决：最好加一句IF检验一下你要replace的内容是否为空。 Microsoft VBScript 编译器错误 错误 ‘800a03f6’ODBC 驱动程序不支持所需的属性。原因：可能是因为没有sql语句里出现的字段名，一般为字段名或sql关键字书写错误。也有可能是sql所要打开的表已经被独占打开。解决方法：检查sql语句里出现的每个字段名，和每个关键字 Microsoft OLE DB Provider for ODBC Drivers 错误 ‘80004005’机器 ‘HDZC-3JQSKBWO02’ 上的用户 ‘Admin’ 以独占方式的锁定数据表’order_detail’。原因：sql所需的表被access以表设计形式打开着解决方法：关闭表设计 Microsoft VBScript 编译器错误 错误 ‘800a03f6’在对应所需名称或序数的集合中，未找到项目。原因：没有sql语句里出现的字段名，一般为字段名或sql关键字书写错误解决方法：检查sql语句里出现的每个字段名 ADODB.Recordset 错误 ‘800a0e78’对象关闭时，不允许操作。原因：在rs.open sql,conn,3,3语句之前使用了rs.close关闭了rs对象解决方法：去掉之前的rs.close Microsoft OLE DB Provider for ODBC Drivers 错误 ‘80040e14’[Microsoft][ODBC Microsoft Access Driver] 语法错误 (操作符丢失) 在查询表达式 ‘oid form classtree where oid = 25’ 中。原因：在sql语句中存在非法书写的英文关键字或子段错误解决方法：把sql语句打出来，然后逐个单词对照，查找出书写的错误 操作要求一个可更新的查询答：看看库文件是不是只读了。答2：经过排序(order by) 的记录集(rs)不允许有更新操作(rs.update) 3219 操作在该内容中不被允许答3：数据库字段属性是否设置为允许空值插入。 adErrInvalidArgument 30010x800A0BB9应用程序使用的参数其类型错误、超出可接受的范围或者与其他参数冲突。 adErrNoCurrentRecord 30210x800A0BCDBOF 或 EOF 为 True，或者当前记录已经删除。应用程序请求的操作需要当前记录。 adErrIllegalOperation 32190x800A0C93应用程序请求的操作不允许出现在该上下文中 adErrInTransaction 32460x800A0CAE在事务中应用程序无法显式关闭 Connection 对象。 adErrFeatureNotAvailable 32510x800A0CB3提供者不支持应用程序请求的操作。 adErrItemNotFound 32650x800A0CC1ADO 无法在对应于应用程序请求的名称或顺序引用的集合中找到对象。 adErrObjectInCollection 33670x800A0D27无法追加，对象已经在集合中。 adErrObjectNotSet 3420 0x800A0D5C 应用程序引用的对象不再指向有效的对象。 adErrDataConversion 34210x800A0D5D应用程序使用了不符合对当前操作的值类型。 adErrObjectClosed 37040x800A0E78如果对象关闭，则不允许应用程序请求的操作。 adErrObjectOpen 37050x800A0E79如果对象打开，则不允许应用程序请求的操作。 adErrProviderNotFound 37060x800A0E7AADO 找不到指定的提供者。 adErrBoundToCommand 37070x800A0E7B应用程序无法用 Command 对象将 Recordset 对象的 ActiveConnection 属性更改为它的来源数据。 adErrInvalidParamInfo 37080x800A0E7C应用程序错误地定义了 Parameter 对象。 adErrInvalidConnection 37090x800A0E7D应用程序通过引用关闭或无效的 Connection 对象来请求对对象的操作。 ADODB.Field 错误 ‘80020009’ BOF 或 EOF 中有一个是“真”，或者当前的记录已被删除，所需的操作要求一个当前的记录。解决如下：这个错误是因SELECT、DELETE的记录不存在，或者库中没有记录所引起的，所以检查SQL语句，SELECT、DELETE的条件是否正确，还有在DELETE前最好SELECT一个记录或者用On Error Resume Next…….On Error Goto 0来处理。如果是因为库中没记录，只要加个判断If objRecordSet.Eof And objRecordSet.Bof Then就可以了，因为打开RecordSet时，指针默认是指在最面的，所以可以只用If objRecordSet.Eof Then来判断 ActiveServerPages,ASP0126(0x80004005)–&gt;找不到包含文件 MicrosoftOLEDBProviderforODBCDrivers(0x80040E21)–&gt;sql语句出错(数据类型不匹配或表名(字段名)错误或表处于编辑状态，或表不存在于conn打开的数据库中)MicrosoftOLEDBProviderforODBCDrivers(0x80040E14)–&gt;sql语句出错(字段名错误,或数据类型不匹配)MicrosoftOLEDBProviderforODBCDrivers(0x80040E07)–&gt;sql语句出错(要插入或更新的字段的类型与变量数据类型不匹配)MicrosoftOLEDBProviderforODBCDrivers(0x80040E57)–&gt;sql语句出错(要插入或更新的数据溢出)MicrosoftOLEDBProviderforODBCDrivers(0x80040E10)–&gt;sql语句出错(update字段名或要更新的数据类型错误)MicrosoftOLEDBProviderforODBCDrivers(0x80004005)–&gt;sql语句出错(要插入或更新的字段的数值不能为空值)MicrosoftOLEDBProviderforODBCDrivers(0x80004005) –&gt;打开数据库出错，没有在指定目录发现数据库MicrosoftOLEDBProviderforODBCDrivers(0x80040E37)–&gt;没有发现表 MicrosoftVBscript运行时错误(0x800A000D)–&gt;错误引用rs变量(rs对像已关闭或未定义)MicrosoftVBscript运行时错误(0x800A01C2)–&gt;vbscript脚本错误(vbscript语句出错)MicrosoftVBscript运行时错误(0x800A0006)–&gt;vbscript脚本错误(溢出错误)MicrosoftVBscript编译器错误(0x800A040E)–&gt;缺少loopMicrosoftVBscript编译器错误(0x800A03EA)–&gt;缺少if或endifMicrosoftVBscript编译器错误(0x800A03EE)–&gt; 语句未结束(缺少”)”)MicrosoftVBscript编译器错误(0x800A03F6)–&gt;if语句出错(缺少endif)MicrosoftVBscript运行时错误(0x800A005B)–&gt;缺少setMicrosoftVBscript运行时错误(0x800A0005)–&gt;变量未定义MicrosoftVBscript编译器错误(0x800A03F9)–&gt;if语句缺少thenMicrosoftVBscript编译器错误(0x800A0411)–&gt;dim语句定义错误 ADODB.Recordset(0x800A0BB9)–&gt;sql语句出错(sql语句或conn语句未定义或对一个rs属性进行赋值时发生错误)ADODB.Recordset(0x800A0CC1)–&gt;rs对像出错(rs对像本身不存在或错误地引用了一个不存在的字段名)ADODB.Recordset(0x800A0BCD)–&gt;rs对像出错(记录集中没有记录却对记录集进行操作)ADODB.Recordset(0x800A0E78)–&gt;rs对像出错(记录集不存在,缺少rs.open语句)ADODB.Recordset(0x800A0CC1) –&gt;rs对像出错(引用了一个不存在的字段名)ADODB.Recordset(0x800A0E7D)–&gt;conn定义错误ADODB.Recordset(0x800A0CB3)–&gt;数据库以只读方式打开，无法更新数据 ASP函数调用给你一个简单的 funcition 和subfunction jisuan()dim a,b,ca=100b=105c=a+b ‘c保存的是a b的和jisuan=c ‘函数返回值需要赋值给函数名才行，这个是必须的end function 调用时：dim abab = jisuan() response.write ab sub 来说只是把一部分代码做成块来分开而已,sub没有返回值 例如：sub jisuan()dim a,ba=100b=105c=a+bend sub 调用时dim ccall jisuan()response.write c","tags":[{"name":"asp","slug":"asp","permalink":"ZYLZYL.github.io/tags/asp/"},{"name":"数据库，sqlsever","slug":"数据库，sqlsever","permalink":"ZYLZYL.github.io/tags/数据库，sqlsever/"}]},{"title":"asp获得当年年份","date":"2017-02-23T01:42:41.000Z","path":"2017/02/23/ASP中让数据库显示当前年份的数据/","text":"ASP中让数据库显示当前年份的数据 当数据库需要显示当前年份时，可以定义一个变量获取当年年份 ，然后在数据库执行SQL语句时加进去。 语句为： Dim nianduniandu=Year(now()) Set rs1 = Server.CreateObject(&quot;ADODB.Recordset&quot;) rs1.ActiveConnection = MM_link_STRING rs1.Source = &quot;SELECT * FROM dbo.t_Benke_Yejitongji_xishu where Ny=&quot;&amp; niandu","tags":[{"name":"asp","slug":"asp","permalink":"ZYLZYL.github.io/tags/asp/"},{"name":"数据库，sqlsever","slug":"数据库，sqlsever","permalink":"ZYLZYL.github.io/tags/数据库，sqlsever/"}]},{"title":"javascript中call()和apply()的区别","date":"2017-02-17T13:38:08.000Z","path":"2017/02/17/javascript中call-和apply-的区别/","text":"JavaScript中有一个call和apply方法，其作用基本相同，但也有略微的区别。 #一、方法定义 ##1、call 方法语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 参数 thisObj 可选项。将被用作当前对象的对象。 arg1, arg2, , argN 可选项。将被传递方法参数序列。 说明 call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作thisObj。说明白一点其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。 ##1、apply 方法语法：apply([thisObj[,argArray]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明： 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 #二、常用实例 ##实例1：call应用实例引用网上一个代码段，运行后自然就明白其道理。&lt;input type=&quot;text&quot; id=&quot;myText&quot; value=&quot;input text&quot;&gt; function Obj(){this.value=&quot;对象！&quot;;} var value=&quot;global 变量&quot;; function Fun1(){alert(this.value);} window.Fun1(); //global 变量 Fun1.call(window); //global 变量 Fun1.call(document.getElementById(&apos;myText&apos;)); //input text Fun1.call(new Obj()); //对象！ window.Fun1(); //global 变量 call函数和apply方法的第一个参数都是要传入给当前对象的对象，及函数内部的this。后面的参数都是传递给当前对象的参数。 运行如下代码： ​ var func=new function(){this.a=”func”} var myfunc=function(x){ var a=”myfunc”; alert(this.a); alert(x); } myfunc.call(func,”var”); 可见分别弹出了func和var。先调用func函数，用this.a=”func”替换myfunc中的this.a ; 然后将”var”传递给方法myfunc的参数x可见分别弹出了func和var。 对于apply和call两者在作用上是相同的，但两者在参数上有区别的。 第一个参数意义都一样。第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 如 func.call(func1,var1,var2,var3) 对应的apply写法为：func.apply(func1,[var1,var2,var3])，同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入。 ##实例2：继承的演示 // 继承的演示 function base() { this.member = “ dnnsun_Member”; this.method = function() { window.alert(this.member); } } function extend() { base.call(this); window.alert(member); window.alert(this.method); } 上面的例子可以看出，通过call之后，extend可以继承到base的方法和属性。 顺便提一下，在javascript框架prototype里就使用apply来创建一个定义类的模式，其实现代码如下： Class = &#123;123456 create: function () &#123; return function () &#123; this.initialize.apply(this, arguments); &#125; &#125;&#125; 解析：从代码看,该对象仅包含一个方法：Create，其返回一个函数，即类。但这也同时是类的构造函数，其中调用initialize，而这个方法是在类创建时定义的初始化函数。通过如此途径，就可以实现prototype中的类创建模式 示例： vehicle=Class.create();12345678910vehicle.prototype=&#123; initialize:function(type)&#123; this.type=type; &#125;, showSelf:function()&#123; alert(&quot;this vehicle is &quot;+ this.type); &#125;&#125;var moto=new vehicle(&quot;Moto&quot;);moto.showSelf(); 运行结果为：this vehicle is Moto ##实例3： function add(a, b) { alert(a + b); } function sub(a, b) { alert(a - b); } add.call(sub, 3, 1);输出结果为：4 这个例子中的意思就是用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 ##实例4： function Animal() { this.name = ‘Animal’; this.showName = function () { alert(this.name); } } function Cat() { this.name = ‘Cat’; } var animal = new Animal(); var cat = new Cat(); //通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。 //输入结果为”Cat” animal.showName.call(cat, ‘,’); //animal.showName.apply(cat,[]); 输出结果为：cat call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name 应该是 Cat。 ##实例5：实现继承 function Animal(name) { this.name = name; this.showName = function () { alert(this.name); } } function Cat(name) { Animal.call(this, name); } var cat = new Cat(‘Black Cat’); cat.showName(); 输出结果为：Black Cat Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了 ##实例6：实现多重继承 var s1 = function(name){ this.name = name; } var s2 = function(sex){ this.sex = sex; } var s3 = function(age){ this.age = age; } var Student = function(name,sex,age,score){ s1.call(this,name); s2.call(this,sex); s3.call(this,age); this.score = score; } Student.prototype.construction = Student; var s = new Student(&apos;jack&apos;,&apos;male&apos;,&apos;12&apos;,&apos;100&apos;); console.log(s.name); //输出:jack console.log(s.sex); //输出:male console.log(s.age); //输出:12 console.log(s.score);//输出:100 这样我们就可以根据各个不同的功能模块分不同的程序员独立开发，最后合并起来，实现了多重继承。 作者： 张燕龙出处：http://www.cnblogs.com/huyong/Email：1074316837@qq.com","tags":[{"name":"js","slug":"js","permalink":"ZYLZYL.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"ZYLZYL.github.io/tags/前端/"}]}]